<!DOCTYPE HTML>
<html>
<head>
<title>MicroProfile CSV viewer</title>
<style>
/* about css: http://bit.ly/1eMQ42U */
body {margin: 0px;padding: 0px; font: 12px Courier New;background-color:#343434; color:white;overflow:hidden;}
ul {list-style-type: none;margin: 0;padding: 0;}
li{display: inline; float:left;border:5px; position:relative;text-align:center;}
a {
    float:left;
    text-decoration:none;
    display: inline;
    text-align: center;
	padding:5px;
	padding-bottom:0px;
	padding-top:0px;
    color: #FFFFFF;
    background-color: #343434;
}
a:hover, a:active{
	background-color: #000000;
}

ul ul {
    position:absolute;
    left:0;
    top:100%;
    margin-left:-999em;
}
li:hover ul {
    margin-left:0;
    margin-right:0;
}
ul li ul{ display:block;float:none;width:100%;}
ul li ul li{ display:block;float:none;width:100%;}
li li a{ display:block;float:none;width:100%;text-align:left;}
#nav li:hover div {margin-left:0;}
.dropzone {display:flex;justify-content:center;align-items:center;font-size:50px;position: fixed; top: 0; left: 0; z-index: 9999999999; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);transition: visibility 175ms, opacity 175ms;}
.help {position:absolute;z-index:5;text-align:left;padding:2px;margin-left:-999em;background-color: #313131;width:300px;}
.helpstart {position:absolute;z-index:5;text-align:left;padding:2px;background-color: #313131;width:300px;display:none}
.root {z-index:1;position:absolute;top:0px;left:0px;}
.filterinputsearchdiv{position:fixed; background-color: #313131;display:none;}
.filterinputsearch{width:100px;}
</style>
</head>
<body style="">
<div style="visibility:hidden; opacity:0" class="dropzone" ondrop="DropHandler(event);" ondragover="DragOverHandler(event);">
Drop .csv file to view CSV data.<br>
Drop multiple .csv files to create a set and view min/max/average<br><br>
h: Show help<br>
1-5: Toggle no. of graphs<br>
Mousewheel/Ctrl + mouse up/down: Zoom<br>
Space: Toggle Set display<br>
</div>
<div class="filterinputsearchdiv" id="FilterInputDiv">Filter<br><input type="text" id="FilterInput" class="filterinputsearch"></div>
<div class="helpstart" id="helpwindow" style="left:20px;top:20px">
History View:<br>
Right Click + Drag : Select Region<br>
Click + Drag: Move Selection<br>
Click Frame : Center on frame<br>
<hr>
Main View:<br>
space: Freeze capturing<br>
x : Toggle View<br>
/ : Rotate connection port % 3<br>
Ctrl + Drag: Pan<br>
Click + Drag: Pan<br>
Enter: Capture selection/Next N Frames
<hr>
<table style="width:100%">
<tr>
<td width="50%" align="left"><a href='javascript:void(0)' onclick="ShowHelp(0);">Close</a></td>
</tr>
</table>
</div>
<canvas id="DetailedView" height="100%" style="background-color:#343434;margin:0px;padding:0px;"></canvas>
<script>
"use strict"


// TODO:
// ZOOM
// Fixup multile different ranges
// make super elaborate tooltip

var FRAME_HISTORY_COLOR_CPU = '#ff7f27';
var FRAME_HISTORY_COLOR_GPU = '#ffffff';

var Settings = {};
var Cookie = {};

const PERCENTILE_SAMPLES = 1000;

var HistoryHeight = 100;
var CanvasDetailedView = document.getElementById('DetailedView');
var CanvasDetailedOffscreen = document.createElement('canvas');
var FilterInput = document.getElementById('FilterInput');
var FilterInputDiv = document.getElementById('FilterInputDiv');
var FilterInputDivPos = {"x":-1,"y":-1,"w":-1,"h":-1};
var FilterInputValueLast = '';

var CanvasArray0 = [];
var CanvasArray1 = [];
var Views = [];

var ViewIndex = 0;

var nWidth = CanvasDetailedView.width;
var nHeight = CanvasDetailedView.height;
var nBackColors = ['#292929', '#343434' ];
var nBackColorsDark = ['#292929', '#272727' ];
var nBackColorOffset = '#404040';
var FontHeight = 10;
var FontHeightLarge = 12;
var FontWidth = 1;
var FontAscent = 3; //Set manually
var Font = 'Bold ' + FontHeight + 'px Courier New';
var FontLarge = 'Bold ' + FontHeightLarge + 'px Courier New';
var FontFlash = 'Bold ' + 35 + 'px Courier New';
var BoxHeight = FontHeight + 2;
var MouseX = 0;
var MouseY = 0;
var MouseReleased = false;
var MouseMoveTime = new Date();

var nBarsWidth = 80;
var nOffsetBarsX = 0;
var nOffsetBarsY = 0;
var nOffsetCountersY = 0;
var nOffsetMenuTimers = 0;
var nOffsetMenuGroup = 0;
var nOffsetMenuFunctions = 0;
var nOffsetMenuModules = 0;
var nOffsetMenuPatched = 0;

var nHoverCounter = -1;

var MouseDragOff = 0;
var MouseDragDown = 1;
var MouseDragUp = 2;
var MouseDragMove = 3;
var MouseDragState = MouseDragOff;
var MouseDragTarget = 0;
var MouseDragButton = 0;
var MouseDragKeyShift = 0;
var MouseDragKeyCtrl = 0;
var MouseDragX = 0;
var MouseDragY = 0;
var MouseDragXLast = 0;
var MouseDragYLast = 0;
var MouseDragXStart = 0;
var MouseDragYStart = 0;

var MouseDragActiveXStart = 0;
var MouseDragActiveXEnd = -1;
var MouseInCaptureButton = 0;

var ToolTipCallback = null;
let ToolTipImmediate = null;

var DPR = 0;
var C_HUGE = 1e10;

var ActivePreset = "Default";
var ActivePresetRO = 0;
var PresetPending = 0;
var Presets = [];
var PresetsCache = {};
var ReadOnlyPresets = [];
var ReadOnlyPresetsCache = {};

Settings.SubGraphSettings = {};
Settings.ReferenceTime = 50.0;
var ReferencePresets = [5.0, 10.0, 15.0, 20, 30, 33.33, 50, 66.66,100.0,250.0,500,1000.0];
var PercentilePresets = [0.0, 1.0, 5.0, 10.0, 50.0, 75.0, 99.0];
var ReferenceTimeTweak = -1;
var PercentileTweak = -1;

Settings.TargetTime = 30;
var TargetTimeTweak = -1;


var AggregateFrames = 60;
Settings.AggregateFrames = 60;
var AggregatePresets = [0, 10,20,30,60,90,120,500];
var AggregateHistorySize = 5;
var AggregateTweak = -1;
var AggregateCurrent = 0;

var AutoCaptureCooldown = -1;
var AutoCaptureEnabled = 0;
var AutoCaptureDefaultThreshold = 66;
Settings.AutoCaptureTheshold = AutoCaptureDefaultThreshold;
Settings.AutoCaptureRepeat = 1;
var AutoCaptureThesholdPresets = [1,3,5,10,15,30,50,66,90,100,250,500,1000];
var AutoCaptureRepeatPresets = [1,2,3,4,5,6,7,8,9,10, 25, 50, 100];
var AutoCaptureTweak = -1;
var AutoCaptureRepeatTweak = -1;
var AutoCaptureSourceTweak = -1;
var AutoCaptureSourceIndex = -1;

var CaptureFramesDefault = 30;
Settings.CaptureFrames = CaptureFramesDefault;
Settings.CaptureDelay = 0;
var CaptureFramesPresets = [5,10,15,30,50,66,90,100];
var CaptureDelayPresets = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var CaptureTweak = -1;
var CaptureDelayTweak = -1;

var CaptureTriggerTime = null;
var CaptureTriggerTimeType = 0;
var CaptureTriggerDelta = 0;

let LastDropTarget = null;


// Begin shared: internal profiling
var ProfileData = {};
var ProfileStackTime = [];
let ProfileStackName = [];
var ProfileMode = 0;
var ProfileRedraw0 = 0;
var ProfileRedraw1 = 0;
var ProfileRedraw2 = 0;
var ProfileFps = 0;
var ProfileMs = 0;
var ProfileFpsAggr = 0;
var ProfileFpsCount = 0;
var ProfileLastTimeStamp = new Date();
function CreateEmptyFloatArray(Size)
{
	let a = Array(Size);
	for(let i = 0; i < Size; ++i)
		a[i] = 0.0;
	return a;
}
function FormatNumber(f, digits)
{
	if(digits >= 0)
		 return ("             " + f.toFixed(digits)).slice(-12).trim();
	else
		return f + "";
}
// End shared: internal profiling


var PlotfArray = new Array();



var ConnectionStr = ["\\", "|", "/", "-" ];
var ConnectionIdx = 0;
var EnabledArray = [];


var FrameData = {};
var FRAME_COUNT = 256;
var FramePending = 0;

var WSConnected = 0;
var WSIsOpen = 0;
var WSSeconds = 0;
var WSFail = 0;
var WS;
var WSHost = location.hostname ? location.hostname : "localhost";
var WSPort = location.port ? location.port : 1338;
var WSPath;

var CaptureButtonX = 0;
var CaptureButtonY = 0;
var GroupsEnabled = 0;
var TimersEnabled = 0;

var TimersActiveOnly = 0;


var MSG_TIMER_TREE = 1;
var MSG_ENABLED = 2;
var MSG_FRAME = 3;
var MSG_LOADSETTINGS = 4;
var MSG_PRESETS = 5;
var MSG_CURRENTSETTINGS = 6;
var MSG_COUNTERS = 7;
var MSG_FUNCTION_RESULTS = 8;
var MSG_INACTIVE_FRAME = 9;
var MSG_FUNCTION_NAMES = 10;
var MSG_INSTRUMENT_ERROR = 11;
// var MSG_MODULE_NAME = 12;


var TYPE_NONE = 0;
var TYPE_TIMER = 1;
var TYPE_GROUP = 2;
var TYPE_CATEGORY = 3;
var TYPE_SETTING = 4;
var TYPE_COUNTER = 5;


var WSSend = 0;
var WSReceive = 0;
var WSSendBytes = 0;
var WSReceiveBytes = 0;
var WSOpenTime = 0;


var TimerArray = [];
var CounterArray = [];
var Empty = {"id":0, "w":0, "depth":0, "sibling":-1,"parent":-1,"firstchild":-1};
var WidthArray = [];
var FunctionQueryArray = [];
var FunctionQueryPending = null;
var FunctionQueryLastRequest = 0;
var FunctionQueryReceived = 0;
var WidthTree = 0;
Settings.ViewActive = 0;
Settings.ViewCompressed = 0;
Settings.AllowHighDPI = 1;
var ViewNames = ["Graph", "Graph", "Graph", "Bars", "Bars", "Bars", "Counters", "CSV Data"];
var ViewNames2 = ["[split]", "[percentile]","[group/thread]","[table]", "[all]", "[single]", "", ""];

var VIEW_GRAPH_SPLIT = 0;
// var VIEW_GRAPH = 1;
var VIEW_GRAPH_PERCENTILE = 1;
var VIEW_GRAPH_THREAD_GROUP = 2;
var VIEW_BAR = 3;
var VIEW_BAR_ALL = 4;
var VIEW_BAR_SINGLE = 5;
var VIEW_COUNTERS = 6;
var VIEW_CSV = 7;
var VIEW_SIZE = 8;

var GRAPH_ALPHA = 0.5;


// Settings.FancyGraph = 1;
Settings.AutomaticReference = 1;
Cookie.CodeReportMode = 0; // 0: prompt, 1:always send, 2: never send, never prompt


var ReferenceHistory = 0;
var ReferenceGraph = 0;
var ReferenceBar = 0;
var ReferenceHistoryAutomatic = 0;
var ReferenceGraphAutomatic = 0;
var ReferenceGraphAutomaticGroup = 0;
var ReferenceBarAutomatic = 0;

var SingleTimerBars = 0;
var History;
var MainView;
let CSVView;
var X7Views;
var X7LegendView;
var X7BarColumnRemap = [0,1,2,3,4,5,6];
var X7BarColumnMask = -1;
var X7LegendOffset = 25;
var X7BarLastView = -1;
var X7BarFirstView = -1;


var ViewBarMaxMsTextLength = 0;

Settings.SortColumnOrderFlip = 0;
Settings.SortColumnName = "";
var SortColumnMouseOverNext = "";


var KeyShiftDown = 0;
var KeyCtrlDown = 0;
var KeyHDown = 0;

var IsFrozen = 0;

var PresetToLoad;
var PresetToLoadRO = 0;
var HelpFade;

let gRange = 1;
let gOffset = 0;
let gGraphCSVInvalid = 1;

// CSV Data
let CSVSets = {};
let CSVAllColumns = {};
let CSVIndex = 0;
let CSVMaxLength = 0;
let CSVNumSets = 0;
let CSVSetNames = [];
let CSVActiveSet = 0;


//let CSVMenuItems = [];

let MAX_GRAPHS = 5;
let Graphs = new Array(MAX_GRAPHS);
let GraphModeMask = 1 | 2;
let NumGraphs = MAX_GRAPHS;

let MouseInGraphButton = 0;
let MouseInGraphModeButton = 0;

let GraphButtonIndex = -1;
let GraphModeButtonIndex = 0;

let GraphButtonX = 0;
let GraphButtonY = 0;

let GraphModeButtonX = 0;
let GraphModeButtonY = 0;

for(let i = 0; i < MAX_GRAPHS; ++i)
{
	Graphs[i] = {};
}


TimerArray.push(Empty); // 0 is root of tree

let CounterNameWidth = 100;
let CounterValueWidth = 100;
let CounterLimitWidth = 100;

let FormatCounterDefault = 0;
let FormatCounterBytes = 1;
let FormatCounterBytesExt = ["b","kb","mb","gb","tb","pb","eb","zb","yb"];



function ConvertHslToRGB(h, s, l) //from https://gist.github.com/mjackson/5311256
{
	let r, g, b;
	if (s == 0)
	{
		r = g = b = l; // achromatic
	}
	else
	{
		function hue2rgb(p, q, t)
		{
			if (t < 0) t += 1;
			if (t > 1) t -= 1;
			if (t < 1/6) return p + (q - p) * 6 * t;
			if (t < 1/2) return q;
			if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
			return p;
		}
		let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		let p = 2 * l - q;
		r = hue2rgb(p, q, h + 1/3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1/3);
	}
	let color = ((r*255)<<16) | ((g*255)<<8) | (b*255);
	return ("000000" + color.toString(16)).slice(-6);
}

function Plotf(str)
{
	PlotfArray.push(str);
}
function PlotfClear()
{
	PlotfArray = new Array();
}

function ProfileModeClear()
{
	if(ProfileMode)
	{
		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			Timer.Count = 0;
			Timer.Time = 0;
		}
		ProfileStackTime = new Array();
		ProfileStackName = new Array();

		RequestDraw();
	}
}
function ProfileEnter(Name, Graph)
{
	if(ProfileMode)
	{
		ProfileStackTime.push(performance.now());
		ProfileStackName.push(Name);
		var Obj = ProfileData[Name];
		if(!Obj)
		{
			Obj = new Object();
			Obj.Count = 0;
			Obj.Name = Name;
			Obj.Time = 0;
			Obj.AggrCount = 0;
			Obj.AggrTime = 0;
			Obj.AggrMax = 0;
			Obj.AvgTime = 0;
			Obj.MaxTime = 0;
			Obj.TotalTime = 0;
			Obj.Graph = Graph;
			Obj.GraphData = CreateEmptyFloatArray(120);
			ProfileData[Name] = Obj;
		}
	}
}
function ProfileLeave()
{
	if(ProfileMode)
	{
		let Time = performance.now();
		let Delta = Time - ProfileStackTime.pop();
		let Name = ProfileStackName.pop();
		let Obj = ProfileData[Name];
		if(Obj)
		{
			Obj.Time += Delta;
			Obj.Count += 1;
		}
	}
}

function ProfilePlot(s)
{
	if(ProfileMode)
	{
		var A = ProfileData.Plot;
		if(!A)
		{
			ProfileData.Plot = Array();
			A = ProfileData.Plot;
		}
		if(A.length<10)
		{
			A.push(s);
		}
	}
}
function ProfileModeDump()
{
	for(var idx in ProfileData)
	{
		var Timer = ProfileData[idx];
		console.log(Timer.Name + " " + Timer.Time + "ms " + Timer.Count);
	}

}
function ProfileModeDraw(Canvas)
{
	if(ProfileMode)
	{
		ProfileFpsCount ++ ;
		var AggrFrames = 60;
		var StringArray = [];
		function FormatTime(f)
		{
			return ("             " + f.toFixed(2)).slice(-12);
		}
		function FormatStr(t, count, avg, max, total)
		{
			var str = FormatTime(t) + "ms " + ("        #" + count).slice(-8) +
			"" + FormatTime(avg) + "ms " + FormatTime(max) + "ms " + FormatTime(total) + "ms";
			return str;
		}
		StringArray.push("");
		StringArray.push("time    count         avg            max       total/" +  AggrFrames + "  ");

		for(var idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			var Timer = ProfileData[idx];
			Timer.AggrCount += Timer.Count;
			Timer.AggrTime += Timer.Time;
			Timer.AggrMax = Math.max(Timer.AggrMax, Timer.Time);
			if(ProfileFpsCount == AggrFrames)
			{
				Timer.AvgTime = Timer.AggrTime / AggrFrames;
				Timer.MaxTime = Timer.AggrMax;
				Timer.TotalTime = Timer.AggrTime;
				Timer.AggrCount = 0;
				Timer.AggrTime = 0;
				Timer.AggrMax = 0;
			}
			PushIntoArray(Timer.GraphData, Timer.Time);
			StringArray.push(Timer.Name);
			StringArray.push(FormatStr(Timer.Time, Timer.Count, Timer.AvgTime, Timer.MaxTime, Timer.TotalTime));
		}
		var Time = new Date();
		var Delta = Time - ProfileLastTimeStamp;
		ProfileLastTimeStamp = Time;
		StringArray.push("Frame Delta");
		StringArray.push(Delta + "ms");
		{
			ProfileFpsAggr += Delta;

			if(ProfileFpsCount == AggrFrames)
			{
				ProfileMs = ProfileFpsAggr / AggrFrames;
				ProfileFps = 1000 / (ProfileFpsAggr / AggrFrames);
				ProfileFpsAggr = 0;
				ProfileFpsCount = 0;
			}
			StringArray.push("Avg FPS");
			StringArray.push("" + ProfileFps.toFixed(2));
			StringArray.push("Avg MS");
			StringArray.push("" + ProfileMs.toFixed(2));
		}
		for(var i = 0; i < ProfileData.Plot; ++i)
		{
			StringArray.push("");
			StringArray.push(ProfileData.Plot[i]);
		}
		ProfileData.Plot = Array();
		DrawToolTip(StringArray, Canvas, 0, 200);

		let Offset = 0;
		let Params = CreateDrawGraph2Parameters();
		Params.Digits = 2;
		var context = Canvas.getContext("2d");
		for(let idx in ProfileData)
		{
			if(idx == "Plot")
				continue;
			let Timer = ProfileData[idx];
			if(Timer.Graph)
			{
				let Mouse = {};
				Mouse.X = MouseX;
				Mouse.Y = MouseY;
				let GraphData = CreateGraph2Data(Timer.GraphData, Timer.Name, ColorFromString(Timer.Name, 75, 65));

				Params.Rect = WindowRect(Offset, nHeight-200, 200, 200);
	 			DrawGraph2(context, Params, [GraphData], Mouse);
	 			Offset += 201;
			}
		}
	}
}



function MeasureFont()
{
	var context = CanvasDetailedView.getContext('2d');
	context.font = Font;
	FontWidth = context.measureText('W').width;

}
function ResizeCanvasDPR(w, h, c)
{
	DPR = Settings.AllowHighDPI ? window.devicePixelRatio : 0;
	if(DPR)
	{
		c.style.width = w + 'px';
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		DPR = 1;
		c.width = w;
		c.height = h;
	}

}

function ResizeCanvasDPR2(w, h, c)
{
	DPR = window.devicePixelRatio;
	if(DPR)
	{
		c.style.width = w + 'px';
		c.style.height = h + 'px';
		c.width = w * DPR;
		c.height = h * DPR;
		c.getContext('2d').scale(DPR,DPR);
	}
	else
	{
		c.width = w;
		c.height = h;
	}

}
function ResizeView(View, x, y, w, h)
{
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	var c0 = View.Canvas[0];
	var c1 = View.Canvas[1];
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);
	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);

}
function CreateView(x, y, w, h, name, DisplayFunc,  visible, index, InvalidFunc)
{
	var idx = Views.length;
	var c0 = CanvasArray0[idx];
	var c1 = CanvasArray1[idx];

	if(!c0)
	{
		c0 = document.createElement('canvas');
		CanvasArray0[idx] = c0;
	}
	if(!c1)
	{
		c1 = document.createElement('canvas');
		CanvasArray1[idx] = c1;
	}
	var View = {};
	View.x = x;
	View.y = y;
	View.w = w;
	View.h = h;
	View.Canvas = [c0, c1];
	View.OffscreenData = [null, null];
	View.visible = visible;
	View.index = index;
	ResizeCanvasDPR(w, h, c0);
	ResizeCanvasDPR(w, h, c1);

	c0.getContext('2d').clearRect(0, 0, w, h);
	c1.getContext('2d').clearRect(0, 0, w, h);
	View.OffscreenData[0] = c0.getContext('2d').getImageData(0, 0, c0.width, c0.height);
	View.OffscreenData[1] = c1.getContext('2d').getImageData(0, 0, c1.width, c1.height);
	View.BackBuffer = 0;
	View.DisplayFunc = DisplayFunc;
	if(InvalidFunc)
		View.InvalidFunc = InvalidFunc;
	else
		View.InvalidFunc = function(){ return true; } ;
	Views.push(View);
	return View;
}

function CreateViews(Width, Height, ViewCompressed)
{
	Views = [];
	MainView = CreateView(0, 0, Width, Height, "Main", DrawGraphSplit, true);

	CSVView = CreateView(0, 0, Width, Height, "CSV", DrawGraphCSV, false, 0, InvalidGraphCSV);


}

function ResizeCanvas()
{
	nWidth = window.innerWidth;
	nHeight = window.innerHeight;
	DPR = Settings.AllowHighDPI ? window.devicePixelRatio : 0;
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedView);
	ResizeCanvasDPR(nWidth, nHeight, CanvasDetailedOffscreen);

	if(DPR)
	{
		CanvasDetailedView.style.width = nWidth + 'px';
		CanvasDetailedView.style.height = nHeight + 'px';
		CanvasDetailedView.width = nWidth * DPR;
		CanvasDetailedView.height = nHeight * DPR;
		CanvasDetailedView.getContext('2d').scale(DPR,DPR);

		CanvasDetailedOffscreen.style.width = nWidth + 'px';
		CanvasDetailedOffscreen.style.height = nHeight + 'px';
		CanvasDetailedOffscreen.width = nWidth * DPR;
		CanvasDetailedOffscreen.height = nHeight * DPR;
		CanvasDetailedOffscreen.getContext('2d').scale(DPR,DPR);

	}
	else
	{
		DPR = 1;
		CanvasDetailedView.width = nWidth;
		CanvasDetailedView.height = nHeight;
		CanvasDetailedOffscreen.width = nWidth;
		CanvasDetailedOffscreen.height = nHeight;
	}
	MeasureFont();
	CreateViews(nWidth, nHeight, Settings.ViewCompressed);
	ActivateView(Settings.ViewActive);
}


function FormatTime(Time)
{
	return Time.toFixed(2);
}


function DrawGraphSplit(View, LocalMouseX, LocalMouseY, SubIndex)
{

}

function InvalidGraphCSV(View, LocalMouseX, LocalMouseY, SubIndex)
{
	return gGraphCSVInvalid;
}

function DrawGraphCSV(FullUpdate, View, Canvas, context, LocalMouseX, LocalMouseY, SubIndex)
{
	ProfileEnter("DrawGraphCSV", 1);
	if(FullUpdate)
	{
		context.clearRect(0, 0, View.w, View.h);
		gGraphCSVInvalid = 0;
	}


	var h = View.h;
	var w = View.w;


	let Params = CreateDrawGraph2Parameters();
	let Mouse = {};
	Mouse.X = LocalMouseX;
	Mouse.Y = LocalMouseY;
	Params.Rect = WindowRect(0, 0, w, h);
	Params.xRange = gRange;
	Params.xOffset = gOffset;
	Params.FullDraw = FullUpdate




	let GraphHeight = h / NumGraphs;
	let y = 0;
	let SetColors = 0;
	for(let set in CSVSets)
		SetColors++;
	if(SetColors < 2)
		SetColors = 0;


	let SetHueBase = [0.175, 0.85, 0.53];
	let SetHueRange = [0.8, 0.14, 0.7];
	let SetS = 96;
	let SetV = 98;
	let SetL = 50;


	for(let i = 0; i < NumGraphs; ++i)
	{
		Params.Rect = WindowRect(0, y, w, GraphHeight);
		let Data = [];
		let GraphColumns = Graphs[i];
		let GraphMode = GraphModeMask;
		for(let SetIndex = 0; SetIndex < CSVSetNames.length; ++SetIndex)
		{
			if(SetIndex == (CSVActiveSet-1) || CSVActiveSet == 0)
			{
				let SetName = CSVSetNames[SetIndex];
				let Set = CSVSets[SetName];
				if(!Set.Ready)
					continue;
				let ColumnIndex = 0;
				for(let ColumnName in GraphColumns)
				{

					if(GraphColumns[ColumnName] == 1 && Set.ColumnNames[ColumnName])
					{
						for(let j = 0; j < 8; ++j)
						{
							if(0 != (GraphMode &(1<<j)))
							{
								let src = null;
								if(j == 0)
									src = Set.GraphDataSect[ColumnName];
								else if(j == 1)
									src = Set.GraphDataAvg[ColumnName];
								else if(j == 2)
									src = Set.GraphDataMin[ColumnName];
								else if(j == 3)
									src = Set.GraphDataMax[ColumnName];
								else if(j == 4)
									src = Set.GraphDataPercentileSect[ColumnName];
								else if(j == 5)
									src = Set.GraphDataPercentileAvg[ColumnName];
								else if(j == 6)
									src = Set.GraphDataPercentileMin[ColumnName];
								else if(j == 7)
									src = Set.GraphDataPercentileMax[ColumnName];
								if(SetColors)
								{
									let ColumnPrc = (ColumnIndex % 5) / 4.0;
									let h = (SetHueBase[SetIndex%3] + SetHueRange[SetIndex%3] * ColumnPrc) * 360;
									let color = "hsl(" + h + "," + SetS + "%," + SetL + "%)";
									src.Color = color;
								}
								Data.push(src);
							}
						}
						ColumnIndex++;
					}
				}
			}
		}
		DrawGraph2(context, Params, Data, Mouse);

		y += GraphHeight;
	}
	ProfileLeave();

}



function StringHash(s) //note: matching code in microprofile.cpp: uint32_t MicroProfileStringHash(const char* pString)
{
	var h = 0xfeedba3e;
	for(var i = 0; i < s.length; ++i)
	{
		h = s.charCodeAt(i) + ((h << 5) - h);
		h = h & h;
	}
	return Math.abs(h);
}

function StringColorIndex(Name)
{
	var h = StringHash(Name);
	var cidx = Math.floor(360*(h  / (1<<32-1)) );
	return cidx;
}

function ColorFromString(Name, S, L)
{
	var H = StringColorIndex(Name);
	return "hsl(" + H + "," + S + "%, " + L+ "%)";
}

function LerpColor(v)
{
	var R_0 = 0;
	var G_0 = 1;
	var B_0 = 0;

	var R_1 = 1;
	var G_1 = 0.5;
	var B_1 = 0;

	var R_2 = 1;
	var G_2 = 0;
	var B_3 = 0;
	var R;
	var G;
	if(v < 0.5)
	{
		v *= 2;
		var v0 = (1-v);
		R = R_0 * v0 + R_1 * v;
		G = G_0 * v0 + G_1 * v;

	}
	else
	{
		v = (v-0.5) * 2;
		var v0 = (1-v);
		R = R_1 * v0 + R_2 * v;
		G = G_1 * v0 + G_2 * v;
	}
	R *= 255;
	G *= 255;
	return "rgb(" + R.toFixed(0) + "," + G.toFixed(0) + ",0)";

}

function DrawRange(context, X, XEnd, Y, YEnd, ColorBack, ColorFront)
{
	if(X < XEnd)
	{
		var W = XEnd - X;
		var H = YEnd - Y;
		context.globalAlpha = 0.1;
		context.fillStyle = ColorBack;
		context.fillRect(X, Y, W, H);
		context.globalAlpha = 1;
		context.strokeStyle = ColorFront;
		context.beginPath();
		context.moveTo(X, 0);
		context.lineTo(X, H);
		context.moveTo(X+W, 0);
		context.lineTo(X+W, H);
		// context.closePath();
		context.stroke();
	}
}


function DrawHistory(View, LocalMouseX, LocalMouseY)
{
	ProfileEnter("DrawHistory");
	var Canvas = View.Canvas[View.BackBuffer];
	var context = Canvas.getContext('2d');
	context.clearRect(0, 0, View.w, View.h);
	if(!FrameData.Time)
		return;
	var fHeight = View.h;
	var fWidth = nWidth / FRAME_COUNT;
	var fHeightScale = fHeight / ReferenceHistory;
	var fX = 0;
	var FrameIndex = -1;
	var MouseDragging = 0;
	var GreenTime = (Settings.TargetTime * 0.9);
	var RedBegin = (Settings.TargetTime * 1.1);
	var LerpDist = 1.0 / (RedBegin - GreenTime);
	var id0 = -1;
	var id1 = -1;

	if(MouseDragActiveXEnd > MouseDragActiveXStart)
	{
		var idx0 = Math.ceil(FRAME_COUNT * MouseDragActiveXStart / nWidth);
		var idx1 = Math.floor(FRAME_COUNT * MouseDragActiveXEnd / nWidth);
		idx0 = Clamp(idx0, 0, FRAME_COUNT-1);
		idx1 = Clamp(idx1, 0, FRAME_COUNT-1);
		id0 = FrameData.Ids[idx0];
		id1 = FrameData.Ids[idx1];
	}


	var ToolTipFrame = -1;
	for(var i = 0; i < FRAME_COUNT; i++)
	{
		var fMs = FrameData.Time[i];
		var fPrc = (fMs - GreenTime) * LerpDist;
		fPrc = Clamp(fPrc, 0, 1);
		var color = LerpColor(fPrc);
		var fid = FrameData.Ids[i];
		if(fid >= id0 && fid <= id1)
		{
			color = 'cyan';
		}else if(FrameData.Frozen[i])
		{
			color = 'purple';
		}


		var fH = fHeightScale * fMs;
		var bMouse = LocalMouseX > fX && LocalMouseX < fX + fWidth+1 && MouseY <= HistoryHeight;
		if(bMouse && !MouseDragging)
		{
			context.fillStyle = FRAME_HISTORY_COLOR_GPU;
			ToolTipFrame = i;
		}
		else
		{
			context.fillStyle = color;
		}
		context.fillRect(fX, fHeight - fH, fWidth-1, fH);
		fX += fWidth;
	}


	DrawRange(context, MouseDragActiveXStart, MouseDragActiveXEnd, 0, HistoryHeight, '#59d0ff', '#00ddff');


	var fH = fHeight - fHeightScale * Settings.TargetTime;
	context.fillStyle = 'wheat';
	context.strokeStyle = 'wheat';
	context.beginPath();
	context.moveTo(0, fH);
	context.lineTo(nWidth, fH);
	// context.closePath();
	context.stroke();
	var YText;
	if(fH > HistoryHeight * 0.25)
	{
		YText = fH - FontAscent;
	}
	else
	{
		YText = fH + FontHeight;
	}

	context.fillText(Settings.TargetTime + 'ms', 3, YText);
	context.textAlign='right';
	context.fillText(FormatTime(ReferenceHistory) + 'ms', nWidth, FontHeight);
	context.textAlign='left';



	if(ToolTipFrame >= 0)
	{
		var fMs = FrameData.Time[ToolTipFrame];
		var Frozen = FrameData.Frozen[ToolTipFrame];
		ToolTipCallback = function()
		{
			var StringArray = [];
			StringArray.push("Frame");
			StringArray.push("" + ToolTipFrame);
			StringArray.push("Time");
			StringArray.push("" + fMs.toFixed(3));
			if(Frozen)
			{
				StringArray.push("Frozen & Unreliable");
				StringArray.push("");
			}
			return StringArray;
		}
	}


	ProfileLeave();

}
function MouseInRect(Rect)
{
	return MouseInside(Rect.x, Rect.y, Rect.w, Rect.h);
}
function MouseInside(X, Y, W, H)
{
	return MouseX >= X && MouseX <= X + W && MouseY >= Y && MouseY <= Y + H;
}

var MessageText = "";
var MessageTimeout = -1;
var MessageTimeoutLast = new Date();
var MessageShowSpinner = 0;
function SetMessage(text, TimeOut, ShowSpinner)
{
	if(TimeOut)
	{
		MessageTimeout = TimeOut;
	}
	else
	{
		MessageTimeout = -1;
	}
	MessageText = text;
	MessageShowSpinner = ShowSpinner;
}
function ClearMessage(Message)
{
	if(Message == MessageText)
	{
		MessageText = "";
		MessageTimeout = -1;
	}
}

function DrawMessage()
{
	var context = CanvasDetailedView.getContext('2d');
	var Now = new Date();
	var Delta = Now - MessageTimeoutLast;
	if(MessageTimeout>0)
	{
		MessageTimeout -= Delta;
		if(MessageTimeout<= 0)
		{
			MessageText = "";
			MessageTimeout = -1;
		}

	}
	MessageTimeoutLast = Now;

	var Text = MessageText;
	var X = nWidth / 2;

	var Y = nHeight / 2;
	context.font = FontFlash;
	context.textAlign = 'center';
	context.fillStyle = 'red';

	function MSG(a, Spinner)
	{
		context.fillText(a, X, Y);
		if(Spinner)
		{
			var w = context.measureText(a).width;
			SpinnerDraw(1, context, SpinnerText0, X + 3 + w*0.5, Y - 25,  30, 30);
			SpinnerDraw(1, context, SpinnerText1, X - 3 - w*0.5 - 30, Y - 25,  30, 30);
		}
		Y -= 60;
	}
	if(!HelpFade)
		HelpFade = new Date();
	var HelpFadeTime = new Date() - HelpFade;
	if(HelpFadeTime < 2000)
	{
		var Alpha = 1 - (HelpFadeTime/2000);
		context.globalAlpha = Alpha;
		context.fillText("Press 'h' for help", X, 200);
		context.globalAlpha = 1;
	}

	if(Text != "")
	{
		MSG(Text);
	}
	if(IsFrozen)
	{
		MSG("FROZEN[space]");
	}

	PresetPending++; //hack: wait 20 frames before showing enable messages to prevent it from showing when loading settings. [[[test]]]
	if(WSIsOpen && PresetPending > 20)
	{
		if(Settings.ViewActive != VIEW_COUNTERS)
		{
			if(GroupsEnabled == 0)
			{
				MSG("Paused: Enable groups in 'Control' menu to unpause");
			}
			if(TimersEnabled == 0 && Settings.ViewActive != VIEW_GRAPH_THREAD_GROUP)
			{
				MSG("Enable Timers or Functions");
			}
		}
	}
	context.textAlign = 'left';
	context.font = Font;
}

function DrawGraphSettingsMenu(context, XBase, Y, width, height)
{
	if(SubMenuActive != SubMenuGraphSettings)
	{
		SubMenuGraphSettingsIndex = -1;
		SubMenuGraphSettingsKey = "";
	}
	if(!ShowMenu())
	{
		return;
	}
	if(!(Settings.ViewActive == VIEW_GRAPH_SPLIT || Settings.ViewActive == VIEW_GRAPH_PERCENTILE))
	{
		return;
	}
	let NumGraphs = 0;
	let TimerMap = FrameData.TimerMap;

	for(let key in TimerMap)
	{
		if(!IsGroup(key))
		{
			let idx = GetTimer(key);
			if(TimerArray[idx].e)
			{
				NumGraphs++;
			}
		}
	}
	let h = height;
	let w = width;
	let hstart = Y;
	let gh = h / NumGraphs;
	NumGraphs = 0;
	for(let key in TimerMap)
	{
		if(!IsGroup(key))
		{
			let idx = GetTimer(key);
			if(TimerArray[idx].e)
			{
				let X = XBase+1;
				let Y = hstart+1;
				let MenuText = ">";
				let w2 = 2 + context.measureText(MenuText).width;
				let bMouseInside = MouseInside(X, Y, w2, 4 + FontHeight);
				context.fillStyle = bMouseInside || (SubMenuGraphSettings == SubMenuActive && SubMenuGraphSettingsIndex == NumGraphs) ? nBackColors[1] : 'black';
				context.fillRect(X, Y, w2, 4 + FontHeight);
				context.fillStyle = '#ffffff';
				context.fillText(MenuText, X, Y + FontHeight);
				context.textAlign = 'left';
				if(bMouseInside)
				{
					SubMenuGraphSettingsIndex = NumGraphs;
					SubMenuGraphSettingsKey = key;
					CaptureButtonX = X + w2 + 2;
					CaptureButtonY = Y;
					EnableMenu(SubMenuGraphSettings);
				}
				NumGraphs++;
				hstart += gh;


			}
		}
	}
}

function DrawCaptureMenu(context)
{
	return;
	MouseInCaptureButton = 0;
	if(!ShowMenu())
	{
		return;
	}

	var CaptureRange = MouseDragActiveXStart < MouseDragActiveXEnd ? "Selection" : (""+Settings.CaptureFrames);
	var CaptureText = "Capture[" + CaptureRange + "]";
	var w = 10 + context.measureText(CaptureText).width;
	var X = nWidth / 2 - w / 2;
	var XCenter = nWidth / 2;
	var Y = nHeight - 30;
	MouseInCaptureButton = MouseInside(X, Y, w, 4 + FontHeight);
	context.textAlign = 'center';
	context.fillStyle = MouseInCaptureButton ? nBackColors[1] : 'black';
	context.fillRect(X, Y, w, 4 + FontHeight);
	context.fillStyle = '#ffffff';
	context.fillText(CaptureText, XCenter, Y + FontHeight);



	X += w + 2;
	var MenuText = "^";
	var w2 = 10 + context.measureText(MenuText).width;
	var bMouseInCaptureMenu = MouseInside(X, Y, w2, 4 + FontHeight);
	context.fillStyle = bMouseInCaptureMenu ? nBackColors[1] : 'black';
	context.fillRect(X, Y, w2, 4 + FontHeight);

	context.fillStyle = '#ffffff';
	context.fillText(MenuText, X + w2*0.5, Y + FontHeight);

	let X1 = X + w2 + 10;
	if(CaptureTriggerDelta)
	{
		let text = FormatTime(CaptureTriggerDelta);
		let w = 10 + context.measureText("text").width;
		context.fillStyle = 'black';
		context.fillRect(X1, Y, w, 4 + FontHeight);
		context.fillStyle = '#ffffff';
		context.fillText(text, X1 + w*0.5, Y + FontHeight);
		X1 += w;
	}

	let Pending = (CaptureTriggerTime != null && CaptureTriggerTimeType == 2);
	if(AutoCaptureEnabled || Pending)
	{
		let d = Dots();
		let AutoStatus = Pending ? (" pending" + Dots()) : "";
		let Source = GetAutoCaptureString();
		let Threshold = FormatTime(Settings.AutoCaptureTheshold);
		let str = "Autocapture " + AutoStatus + " Source:'" + Source + "' Threshold:" + Threshold + "ms Repeat=" + (Pending?Settings.AutoCaptureRepeat:AutoCaptureEnabled);
		let w = 10 + context.measureText(str).width;
		context.fillStyle = 'black';
		context.fillRect(X1, Y, w, 4 + FontHeight);
		context.fillStyle = '#ffffff';
		context.fillText(str, X1 + w*0.5, Y + FontHeight);
		X1 += w;
	}

	context.textAlign = 'left';
	if(bMouseInCaptureMenu)
	{
		CaptureButtonX = X + w2;
		CaptureButtonY = Y;
		EnableMenu(SubMenuCapture);
	}
}

function DrawRootGraphMenuElement(context)
{
	MouseInGraphButton = -1;
	MouseInGraphModeButton = -1;
	if(!ShowMenu())
	{
		return;
	}
	let y = 0;
	let ydelta = nHeight / NumGraphs;
	for(let i = 0; i < NumGraphs; ++i)
	{
		let Text = "Source";
		var w = 10 + context.measureText(Text).width;
		var X = nWidth / 2 - w / 2;
		var XCenter = nWidth / 2;
		var Y = y;
		let Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

		context.textAlign = 'center';
		context.fillStyle = Inside ? nBackColors[1] : 'black';
		context.fillRect(X, Y, w, 4 + FontHeight);
		context.fillStyle = '#ffffff';
		context.fillText(Text, XCenter, Y + FontHeight);
		context.textAlign = '';

		if(Inside)
		{
			MouseInGraphButton = i;
			GraphButtonX = X + 4;
			GraphButtonY = Y + FontHeight + 4;
			GraphButtonIndex = MouseInGraphButton;
			EnableMenu(SubMenuGraph);
		}

		X += w + 10;

		if(i == 0)
		{
			Text = "Mode";
			w = 10 + context.measureText(Text).width;
			XCenter = X + w / 2;
			Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

			context.textAlign = 'center';
			context.fillStyle = Inside ? nBackColors[1] : 'black';
			context.fillRect(X, Y, w, 4 + FontHeight);
			context.fillStyle = '#ffffff';
			context.fillText(Text, XCenter, Y + FontHeight);
			context.textAlign = '';

			if(Inside)
			{
				MouseInGraphModeButton = i;
				GraphModeButtonX = X + 2;
				GraphModeButtonY = Y + FontHeight + 2;
				GraphModeButtonIndex = MouseInGraphModeButton;
				EnableMenu(SubMenuGraphMode);
			}

			X += w + 10;

			if(CSVNumSets > 1)
			{
				let Text = "Set: " + (CSVActiveSet == 0 ? "All" : CSVSetNames[CSVActiveSet-1]);
				w = 10 + context.measureText(Text).width;
				XCenter = X + w / 2;
				Inside = MouseInside(X, Y, w, 4 + FontHeight) ;

				context.textAlign = 'center';
				context.fillStyle = Inside ? nBackColors[1] : 'black';
				context.fillRect(X, Y, w, 4 + FontHeight);
				context.fillStyle = '#ffffff';
				context.fillText(Text, XCenter, Y + FontHeight);
				context.textAlign = '';

				if(Inside && MouseReleased)
				{
					CSVActiveSet = (CSVActiveSet + 1) % (CSVNumSets+1);
					gGraphCSVInvalid = 1;
					RequestDraw();
				}
			}


		}
		y += ydelta;
	}
}

function UpdateX7Views()
{
	if(Settings.ViewActive == VIEW_BAR_SINGLE || Settings.ViewActive == VIEW_BAR_ALL)
	{
		var NumSubViews = 0;
		var BarColumnEnabled = GetBarColumnEnabled();
		X7BarFirstView = -1;
		X7BarLastView = -1;
		var ViewMask = 0;
		for(var i = 0; i < BarColumnEnabled.length; ++i)
		{
			if(BarColumnEnabled[i])
			{
				if(X7BarFirstView == -1)
					X7BarFirstView = i;
				X7BarColumnRemap[NumSubViews++] = i;
				ViewMask = ViewMask | (1 << i);
				X7BarLastView = i;
			}
		}
		if(ViewMask != X7BarColumnMask)
		{
			console.log("resizing views");
			var w = NumSubViews ? nWidth / NumSubViews : 1;
			for(var i = 0; i < X7Views.length; ++i)
			{
				X7Views[i].visible = i < NumSubViews;
				if(i < NumSubViews)
				{
					var HistoryH = Settings.ViewCompressed ? 0 : HistoryHeight;
					ResizeView(X7Views[i], w*i, HistoryH, w, nHeight - HistoryH);
				}
			}
			X7BarColumnMask = ViewMask;
		}
		X7LegendView.visible = true;
		ReferenceBarAutomatic = 0;
	}
}
function DrawViews()
{
	Plotf("DrawViews");
	//UpdateX7Views();
	ProfileEnter("UpdateViews");
	ViewIndex = 0;
	for(let i = 0; i < Views.length; ++i)
	{
		let View = Views[i];
		let LocalMouseX = MouseX - View.x;
		let LocalMouseY = MouseY - View.y;
		if(View.visible && View.InvalidFunc(View, LocalMouseX, LocalMouseY, View.index))
		{
			let Canvas = View.Canvas[View.BackBuffer];
			let Context = Canvas.getContext('2d');
			View.DisplayFunc(1, View, Canvas, Context, LocalMouseX, LocalMouseY, View.index);
			ViewIndex++;
		}
	}
	ProfileLeave();
	var context = CanvasDetailedView.getContext('2d');
	context.clearRect(0, 0, nWidth, nHeight);
	ProfileEnter("BlitViews",1);
	for(var i = 0; i < Views.length; ++i)
	{
		var View = Views[i];
		let LocalMouseX = MouseX - View.x;
		let LocalMouseY = MouseY - View.y;
		if(View.visible)
		{
			context.drawImage(View.Canvas[View.BackBuffer], Math.floor(View.x), Math.floor(View.y), View.w, View.h);

			View.DisplayFunc(0, View, CanvasDetailedView, context, LocalMouseX, LocalMouseY, View.index);

		}
	}
	ProfileLeave();
	DrawCaptureMenu(context);
	DrawGraphSettingsMenu(context, MainView.x, MainView.y, MainView.w, MainView.h);

	DrawRootGraphMenuElement(context);



}
var SubMenuGroup = 0;
var SubMenuTimers = 1;
var SubMenuModules = 2;
var SubMenuFunctions = 3;
var SubMenuPatched = 4;
var SubMenuSettings = 5;
var SubMenuViews = 6;
var SubMenuPresets = 7;
var SubMenuColumns = 8;
var SubMenuCapture = 9;


var SubMenuGraphSettings = 10;
var SubMenuGraphSettingsIndex = -1;
var SubMenuGraphSettingsKey = "";
let SubMenuGraph = 11;

let SubMenuGraphMode = 12;


var SubMenuActive = -1;
var SubMenuTimeoutBase = 0.7;
var SubMenuMouseX = 0;
var SubMenuMouseY = 0;
var SubMenuTimeout = new Date();
var MenuItems = [];
var FilterInputTimersValue = '';
var FilterInputGroupsValue = '';
var FilterInputModulesValue = '';
var FilterInputFunctionsValue = '';
var FilterInputPatchedValue = '';


function MakeMenuItem(name, f, visible)
{
	var Item = {};
	Item.name = name;
	Item.f = f;
	Item.w = name.length;
	Item.x = 0;
	Item.y = 0;
	Item.visible = visible;
	return Item;
}
function EnableMenu(m)
{
	gGraphCSVInvalid = 1;
	if(m != SubMenuActive)
	{
		if(SubMenuActive == SubMenuTimers)
		{
			FilterInputTimersValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuGroup)
		{
			FilterInputGroupsValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuModules)
		{
			FilterInputModulesValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuFunctions)
		{
			FilterInputFunctionsValue = FilterInput.value;
		}
		else if(SubMenuActive == SubMenuPatched)
		{
			FilterInputPatchedValue = FilterInput.value;
		}

		SubMenuActive = m;
		SubMenuTimeout = new Date();

		if(SubMenuActive == SubMenuTimers)
		{
			FilterInput.value = FilterInputTimersValue;
		}
		else if(SubMenuActive == SubMenuGroup)
		{
			FilterInput.value = FilterInputGroupsValue;
		}
		else if(SubMenuActive == SubMenuModules)
		{
			FilterInput.value = FilterInputModulesValue;
		}
		else if(SubMenuActive == SubMenuFunctions)
		{
			FilterInput.value = FilterInputFunctionsValue;
		}
		else if(SubMenuActive == SubMenuPatched)
		{
			FilterInput.value = FilterInputPatchedValue;
		}

		FilterInputValueLast = FilterInput.value;
	}
	if(m == -1)
	{
		SubMenuTimeout = 0;
	}

	if(SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuModules || SubMenuActive == SubMenuFunctions || SubMenuActive == SubMenuPatched)
	{
		FilterInputDiv.style['display'] = 'inline';
		FilterInput.focus();
	}
	else
	{
		FilterInputDiv.style['display'] = 'none';
	}
}

function Clamp(v, low, high)
{
	return v < low ? low : (v > high ? high : v);
}
function TriggerCapture()
{
	if(Settings.CaptureDelay <= 0)
	{
		Capture();
	}
	else
	{
		CaptureTriggerTime = new Date();
		CaptureTriggerTimeType = 1;
	}
}

function InitMenu()
{
	MenuItems = [];
	MenuItems.push(MakeMenuItem("Control", function(){EnableMenu(SubMenuGroup); } ));
	MenuItems.push(MakeMenuItem("Timers", function(){EnableMenu(SubMenuTimers); } ));
	MenuItems.push(MakeMenuItem("Modules", function(){EnableMenu(SubMenuModules); } ));
	MenuItems.push(MakeMenuItem("Functions", function(){EnableMenu(SubMenuFunctions); } ));
	MenuItems.push(MakeMenuItem("Patched", function(){EnableMenu(SubMenuPatched); }, function(){ return FunctionsInstrumented.length > 0;} ));
	MenuItems.push(MakeMenuItem("Settings", function(){ EnableMenu(SubMenuSettings); } ));
	MenuItems.push(MakeMenuItem("Views", function(){ EnableMenu(SubMenuViews); } ));
	MenuItems.push(MakeMenuItem("Presets", function(){ EnableMenu(SubMenuPresets); } ));
	MenuItems.push(MakeMenuItem("Columns", function(){ EnableMenu(SubMenuColumns); } ));
}
function DrawTopMenu()
{
	return;
	var context = CanvasDetailedView.getContext('2d');
	var X = 2;
	var Y = 0;
	var MouseInY = MouseY < BoxHeight;
	for(var i = 0; i < MenuItems.length; ++i)
	{
		if(i == SubMenuColumns)
		{
			if(Settings.ViewActive == VIEW_GRAPH_SPLIT ||
				Settings.ViewActive == VIEW_GRAPH_THREAD_GROUP ||
				Settings.ViewActive == VIEW_GRAPH_PERCENTILE ||
				Settings.ViewActive == VIEW_COUNTERS ||
				Settings.ViewActive == VIEW_CSV)
			{
				continue;
			}
		}
		var Item = MenuItems[i];
		if(Item.visible == null || Item.visible())
		{
			var w = context.measureText(Item.name).width + 4;
			var MouseIn = MouseInY && MouseX >= X && MouseX < X + w;
			var color = MouseIn ? nBackColors[1] : "black";
			Item.x = X;
			Item.y = Y + BoxHeight;
			if(MouseIn)
			{
				context.fillStyle = 'white';
				context.fillRect(X-2, Y, w+4, BoxHeight);
				// Enable
				EnableMenu(i);
			}
			context.fillStyle = color;
			context.fillRect(X, Y, w, BoxHeight);
			context.fillStyle = "white";
			context.fillText(Item.name, X+2, Y+BoxHeight-FontAscent);
			if(MouseIn && MouseReleased)
			{
				Item.f();
			}
			X += w + 6;
		}
	}
}

function AggregateMenuSize()
{
	var w = 250 + 5 + FontWidth;
	return WindowRect(nWidth / 2 - w / 2,HistoryHeight + 50, w, nHeight);
}
function TimerMenuSize()
{
	return MenuSize(WidthArray[TYPE_TIMER] + WidthArray[TYPE_GROUP] + 5 + FontWidth);
}

function GroupMenuSize()
{
	return MenuSize(WidthTree);
}

function MenuSize(w)
{
	return WindowRect(nWidth / 2 - w / 2, HistoryHeight + 50,w, nHeight);
}

function CreateFilter(Filter)
{
	if(!Filter || Filter.length == 0)
	{
		return null;
	}
	Filter = Filter.split(' ');

	var regexp = "";
	for(var i = 0; i < Filter.length; ++i)
	{
		regexp = regexp + ".*" + Filter[i];
	}
	Filter = new Array();
	regexp = regexp + ".*";
	Filter.push(new RegExp(regexp, "i"));
	return Filter;
}

function FilterMatch(FilterArray, value)
{
	if(!FilterArray)
		return true;
	for(var i = 0; i < FilterArray.length; ++i)
	{
		var res = value.search(FilterArray[i]);
		if(res<0)
			return false;
	}
	return true;
}

function AddPreset(Name)
{
	var O = {};
	O[Name] = {};
	var OO = {};
	OO.p = O;
	OO.r = {};
	AddPresets(OO);
}
function JSONTryParse(str)
{
	if(typeof str == 'string')
	{
		try{
			return JSON.parse(str);
		}
		catch(e){}
	}
	return {};
}

function ProcessPresets(Data, Names, Cache)
{
	for(var idx in Data)
	{
		if(Names.indexOf(idx) == -1)
		{
			Names.push(idx);
		}
		Cache[idx] = JSONTryParse(Data[idx]);
	}
}
function AddPresets(Obj)
{
	var Names = Obj.p;
	var ReadOnlyNames = Obj.r;
	ProcessPresets(Obj.p, Presets, PresetsCache);
	ProcessPresets(Obj.r, ReadOnlyPresets, ReadOnlyPresetsCache);
}
function GetFullName(T)
{
	var parent = T.parent;
	var ParentName = "unknown";
	var Name = T.name;
	if(parent && parent < TimerArray.length)
	{
		ParentName = TimerArray[parent].name;
	}
	return ParentName + "/" + Name;
}

function ColorFromFullName(name, type)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		if(t.idtype == type && GetFullName(t) == name)
		{
			return t.color;
		}
	}
	return 'white';

}
function EnableByName(name, type)
{
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		if(t.idtype == type && GetFullName(t) == name)
		{
			WSSendMessage("c" + t.id);
		}
	}
}


function OnLoadPreset(NewSettings, Apply, RO)
{
	if(Apply)
	{
		WSSendMessage("d");
		PresetPending = 0;
	}
	ActivePreset = NewSettings.PresetName;
	ActivePresetRO = RO ? 1 : 0;
	console.log('loading preset ' + ActivePresetRO);
	var EnableCount = 0;
	for(var idx in NewSettings)
	{
		if(idx == 'Timers')
		{
			if(Apply)
			{
				var Timers = NewSettings[idx];
				for(var i = 0; i < Timers.length; ++i)
				{
					var FullName = Timers[i];
					EnableCount++;
					EnableByName(FullName, TYPE_TIMER);
				}
			}
		}
		else if(idx == 'Groups')
		{
			if(Apply)
			{
				var Groups = NewSettings[idx];
				for(var i = 0; i < Groups.length; ++i)
				{
					var FullName = Groups[i];
					EnableByName(FullName, TYPE_GROUP);

				}
			}
		}
		else
		{
			Settings[idx] = NewSettings[idx];
		}
	}

	if(Settings.FunctionsInstrumented && Apply)
	{
		if(Settings.FunctionsInstrumented.length == Settings.FunctionsInstrumentedModule.length && Settings.FunctionsInstrumented.length == Settings.FunctionsInstrumentedUnmangled.length)
		{
			var Msg = "D" + Settings.FunctionsInstrumented.length + " ";
			for(var i = 0; i < Settings.FunctionsInstrumented.length; ++i)
			{
				Msg += Settings.FunctionsInstrumentedModule[i] + "!" + Settings.FunctionsInstrumentedUnmangled[i] + "!";
			}
			WSSendMessage(Msg);
		}
	}
	if(Settings.ViewActive >= 0)
	{
		ResizeCanvas();
	}
}
function SanitizeString(s)
{
	let r = "";
	for(let i = 0; i < s.length; ++i)
	{
		let c = s[i];
		if(!((c>='a' && c<='z') || (c >='A' && c <= 'Z') || (c >= '0' && c <= '9')))
		{
			r += '_';
		}
		else
		{
			r += c;
		}
	}
	return r;
}
function LoadPreset(Name, RO)
{
	Name = SanitizeString(Name);
	WSSendMessage((RO?"m":"l")+Name);
}

function SavePreset(Name)
{
	Name = SanitizeString(Name);
	AddPreset(Name);
	var Timers = [];
	var Groups = [];
	for(var i = 0; i < TimerArray.length; ++i)
	{
		var t = TimerArray[i];
		var idtype = TimerArray[i].idtype;
		if(t.e)
		{
			if(idtype == TYPE_TIMER)
			{
				Timers.push(GetFullName(t));
			}
			else if(idtype == TYPE_GROUP)
			{
				Groups.push(GetFullName(t));
			}
		}
	}

	Settings.Timers = Timers;
	Settings.Groups = Groups;
	Settings.PresetName = Name;
	let Clone = function(A)
	{
		let N = Array(A.length);
		for(var i = 0; i < A.length; ++i)
		{
			N[i] = A[i];
		}
		return N;
	};
	Settings.FunctionsInstrumented = Clone(FunctionsInstrumented);
	Settings.FunctionsInstrumentedModule = Clone(FunctionsInstrumentedModule);
	Settings.FunctionsInstrumentedUnmangled = Clone(FunctionsInstrumentedUnmangled);

	var JsonSettings = JSON.stringify(Settings);
	console.log('settings stored ' + JsonSettings);
	WSSendMessage("s"+Name+","+JsonSettings);
	ActivePreset = Name;
	ActivePresetRO = 0;
}
function DrawMenuPresets()
{
	var Selection = null;
	var SizeInfo = {};
	SizeInfo.h = BoxHeight * (Presets.length * 2);
	if(ReadOnlyPresets.length)
	{
		SizeInfo.h += BoxHeight * (Presets.length + 1);
	}
	var x = MenuItems[SubMenuPresets].x;
	var y = MenuItems[SubMenuPresets].y;

	var Width = 50;
	var WLeft = MeasureArray(0, ["Save ", "Load ", "Save As ..", "Builtin" ]);
	Width = MeasureArray(Width, Presets);
	var Width = 35 + Width + WLeft;
	SizeInfo.w = Width;
	SizeInfo.x = x;
	SizeInfo.y = y;

	var M = CreateMenuState(SizeInfo);
	var context = CanvasDetailedView.getContext('2d');

	var SettingsCached;
	var SettingsCachedY = 0;

	for(var i = 0; i < Presets.length; ++i)
	{
		var Active = (ActivePresetRO == 0 && ActivePreset == Presets[i]) ? 1 : 0;
		if(DrawMenuElementMouseIn(M))
		{
			SettingsCachedY = M.y;
			SettingsCached = PresetsCache[Presets[i]];
		}

		if(DrawMenuElement(M, Active, "Load", Presets[i], 'white', 0))
		{
			LoadPreset(Presets[i]);
		}
	}
	DrawMenuElement(M, 0, "---", "", 'white', 0);
	if(DrawMenuElement(M, 0, "Save As..", "", 'white', 0))
	{
		var str = ShowPrompt('Enter Preset Name', '');
		if(str.length>1)
		{
			SavePreset(str);
		}

	}

	for(var i = 0; i < Presets.length; ++i)
	{
		var Active = (ActivePresetRO == 0 && ActivePreset == Presets[i]) ? 1 : 0;
		if(DrawMenuElement(M, Active, "Save", Presets[i], 'white', 0))
		{
			SavePreset(Presets[i]);
		}
	}
	if(ReadOnlyPresets && ReadOnlyPresets.length > 0)
	{
		DrawMenuElement(M, 0, "---", "", 'white', 0);
		for(var i = 0; i < ReadOnlyPresets.length; ++i)
		{
			var Active = (ActivePresetRO && ActivePreset == ReadOnlyPresets[i]) ? 1 : 0;
			if(DrawMenuElementMouseIn(M))
			{
				SettingsCachedY = M.y;
				SettingsCached = ReadOnlyPresetsCache[ReadOnlyPresets[i]];
			}
			if(DrawMenuElement(M, Active, "Builtin", ReadOnlyPresets[i], 'white', 0))
			{
				LoadPreset(ReadOnlyPresets[i], 1);
			}
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;


	if(SettingsCached)
	{
		var SizeLeft = 10 * FontWidth;
		var Timers = SettingsCached.Timers;
		var Groups = SettingsCached.Groups;
		var Patched = SettingsCached.Patched;
		var W = 0;
		var H = 0;
		if(Timers)
		{
			W = MeasureArray(W, Timers);
			H = 1 + Timers.length;
		}
		if(Groups)
		{
			W = MeasureArray(W, Groups);
			H = 1 + Groups.length;
		}
		if(Patched)
		{
			W = MeasureArray(W, Patched);
			H = 1 + Patched.length;
		}
		W += 40;
		H = H * (FontHeight+1);
		var M = CreateMenuState(SizeInfo);
		M.x += M.w + 5;
		M.y = SettingsCachedY;
		M.w = W;
		M.h = H;

		if(Groups && Groups.length)
		{
			DrawMenuElement(M, 0, "Groups", "", 'white', 0);
			for(var i = 0; i < Groups.length; ++i)
			{
				DrawMenuElement(M, 0, "", Groups[i], 'white', 0);
			}
		}
		if(Timers && Timers.length)
		{
			DrawMenuElement(M, 0, "Timers", "", 'white', 0);
			for(var i = 0; i < Timers.length; ++i)
			{
				DrawMenuElement(M, 0, "", Timers[i], ColorFromFullName(Timers[i], TYPE_TIMER), 0);
			}
		}
		if(Patched && Patched.length)
		{
			DrawMenuElement(M, 0, "Patched", "", 'white', 0);
			for(var i = 0; i < Patched.length; ++i)
			{
				DrawMenuElement(M, 0, "", Patched[i], 'white', 0);
			}
		}


	}

	return SizeInfo;
}

function DrawMenuColumns()
{
	var Selection = null;
	var SizeInfo = {};
	var BarColumnNames = GetBarColumnNames();
	var BarColumnEnabled = GetBarColumnEnabled();
	SizeInfo.h = BoxHeight * (BarColumnNames.length);
	var x = MenuItems[SubMenuColumns].x;
	var y = MenuItems[SubMenuColumns].y;

	var Width = MeasureArray(0, BarColumnNames);
	SizeInfo.w = Width;
	SizeInfo.x = x;
	SizeInfo.y = y;

	var M = CreateMenuState(SizeInfo);
	var context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);


	for(var i = 0; i < BarColumnNames.length; ++i)
	{
		var Active = ActivePreset == Presets[i] ? 1 : 0;
		if(DrawMenuElement(M, BarColumnEnabled[i], BarColumnNames[i], "", 'white', 0))
		{
			BarColumnEnabled[i] = !BarColumnEnabled[i];
			for(var j = 0; j < ColumnsWidth.length; ++j)
			{
				ColumnsWidth[i] = 20;
			}
		}
	}

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}


function ToggleView()
{
	Settings.ViewActive = (Settings.ViewActive+1) % VIEW_SIZE;
	ActivateView(Settings.ViewActive);
}

function ActivateView(idx)
{
	for(var i = 1; i < Views.length; ++i)
	{
		Views[i].visible = false;
	}
	History.visible = !Settings.ViewCompressed && idx != VIEW_CSV;
	//Views[i].visible = false;
	if(idx == VIEW_GRAPH_SPLIT)
	{
		MainView.DisplayFunc = DrawGraphSplit;
		MainView.visible = true;
	}
	else if(idx == VIEW_GRAPH_PERCENTILE)
	{
		MainView.DisplayFunc = DrawGraphPercentile;
		MainView.visible = true;
	}
	else if(idx == VIEW_GRAPH_THREAD_GROUP)
	{
		MainView.DisplayFunc = DrawGraphThreadGroup;
		MainView.visible = true;
	}
	else if(idx == VIEW_BAR)
	{
		MainView.DisplayFunc = DrawTableView;
		MainView.visible = true;
	}
	else if(idx == VIEW_COUNTERS)
	{
		MainView.DisplayFunc = DrawCounterView;
		MainView.visible = true;
	}
	else if(idx == VIEW_BAR_SINGLE || idx == VIEW_BAR_ALL)
	{
		for(var i = 0; i < X7Views.length; ++i)
		{
			X7Views[i].visible = true;
		}
		SingleTimerBars = idx == VIEW_BAR_SINGLE;
	}
	else if(idx == VIEW_CSV)
	{
		CSVView.visible = true;
	}

	Settings.ViewActive = idx;
	X7BarColumnMask = -1;
	ViewBarMaxMsTextLength  = 0;
	var hest = 3;
}
function DrawMenuViews()
{
	var ViewClick = function(idx, name)
	{
		ActivateView(idx);
	};
	var x = MenuItems[SubMenuViews].x;
	var y = MenuItems[SubMenuViews].y;
	return DrawMenuGeneric(ViewNames, Settings.ViewActive, ViewClick, x, y, ViewNames2);
}

function TweakValue(Value, Tweak, amount, Min, Max)
{
	var V = 0.98;
	if(Tweak<0)
	{
		for(var x = 0; x < Math.abs(Tweak); ++x)
		{
			var newValue = Math.floor(Value*V);
			if(newValue == Value)
			{
				Value--;
			}
			else
			{
				Value = newValue;
			}
		}
	}
	else
	{
		var RcpV = 1.0 / V;

		for(var x = 0; x < Tweak; ++x)
		{
			var newValue = Math.ceil(Value*RcpV);
			if(newValue == Value)
			{
				Value++;
			}
			else
			{
				Value = newValue;
			}
		}
	}
	if(Min!=null && Value < Min)
		Value = Min;
	if(Max!=null && Value > Max)
		Value = Max;
	return Value;

}

function NextValue(Presets, Value, Dir)
{
	var idx = 0;
	if(Dir > 0)
	{
		for(idx = 0;idx < Presets.length; ++idx)
		{
			if(Presets[idx] > Value)
			{
				break;
			}
		}
	}
	else
	{
		for(idx = Presets.length; idx >= 0; idx -= 1)
		{
			if(Presets[idx] < Value)
			{
				break;
			}
		}
	}
	idx = (idx + Presets.length) % Presets.length;
	return Presets[idx];
}
function AutoCaptureRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.AutoCaptureTheshold = SetDirect;
	}
	else if(Tweak)
	{
		Settings.AutoCaptureTheshold = TweakValue(Settings.AutoCaptureTheshold, Tweak, 0.98, 1, 500);
	}
	else if(Direction)
	{
		Settings.AutoCaptureTheshold = NextValue(AutoCaptureThesholdPresets, Settings.AutoCaptureTheshold, Direction);
	}
}
function AutoCaptureRepeatRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.AutoCaptureRepeat = SetDirect;
	}
	else if(Tweak)
	{
		Settings.AutoCaptureRepeat = TweakValue(Settings.AutoCaptureRepeat, Tweak, 0.98, 1, 500);
	}
	else if(Direction)
	{
		Settings.AutoCaptureRepeat = NextValue(AutoCaptureRepeatPresets, Settings.AutoCaptureRepeat, Direction);
	}
}
function CaptureRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.CaptureFrames = SetDirect;
	}
	else if(Tweak)
	{
		Settings.CaptureFrames = TweakValue(Settings.CaptureFrames, Tweak, 0.98, 5, 300);

	}
	else if(Direction)
	{
		Settings.CaptureFrames = NextValue(CaptureFramesPresets, Settings.CaptureFrames, Direction);
	}
}
function CaptureDelayRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.CaptureDelay = SetDirect;
	}
	else if(Tweak)
	{
		Settings.CaptureDelay = TweakValue(Settings.CaptureDelay, Tweak, 0.98, 5, 300);

	}
	else if(Direction)
	{
		Settings.CaptureDelay = NextValue(CaptureDelayPresets, Settings.CaptureDelay, Direction);
	}
}

function GetAutoCaptureString()
{
	if(AutoCaptureSourceIndex >= 0)
	{
		if(AutoCaptureSourceIndex >= EnabledArray.length)
		{
			AutoCaptureSourceIndex = -1;
			AutoCaptureSourceIndex = -1;
		}
		else
		{
			var idx = EnabledArray[AutoCaptureSourceIndex];
			return TimerArray[idx].name;
		}
	}
	return "Frame Time";
}

function AutoCaptureSourceRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{

	}else if(Tweak||Direction)
	{
		if(!Direction)
			Direction = Tweak;
		if(Direction<0)
		{
			AutoCaptureSourceIndex--;
			if(AutoCaptureSourceIndex<-1)
			{
				AutoCaptureSourceIndex = EnabledArray.length-1;
			}
		}
		else
		{
			AutoCaptureSourceIndex++;
			if(AutoCaptureSourceIndex >= EnabledArray.length)
			{
				AutoCaptureSourceIndex = -1;
			}
		}

	}
}

function ShowPrompt(Title, Value, Type)
{
	var v;
	if(Type == 'int')
	{
		var newValue = prompt('' + Title, '' + Value);
		v = parseInt(newValue);
	}
	else if(Type == 'float')
	{
		var newValue = prompt('' + Title, '' + Value);
		v = parseFloat(newValue);
	}
	else
	{
		var v = prompt('' + Title, '' + Value);
		return v;
	}
	if(isNaN(v))
	{
		return Value;
	}
	else
	{
		return v;
	}

}
function MeasureArray(v, A, f)
{
	let context = CanvasDetailedView.getContext('2d');
	for(let i = 0; i < A.length; ++i)
	{
		let s = A[i];
		if(f)
			s=f(s, i);
		let l = context.measureText(s).width;
		v = v < l ? l : v;
	}
	return v;
}
function MeasureObjectKeys(v, A, f)
{
	let context = CanvasDetailedView.getContext('2d');
	for(let i in A)
	{
		let l = context.measureText(i).width;
		v = v < l ? l : v;
	}
	return v;
}

function CreateMenuState(SizeInfo)
{
	var MenuState = {};
	for(var i in SizeInfo)
	{
		MenuState[i] = SizeInfo[i];
	}
	MenuState.cidx = 0;
	return MenuState;
}
function DrawMenuElementMouseIn(M)
{
	return MouseY >= M.y && MouseY < M.y + BoxHeight && MouseX >= M.x && MouseX <= M.x + M.w;
}
function DrawMenuElement(M, Selected, Name, Value, color)
{
	var context = CanvasDetailedView.getContext('2d');

	var bMouseIn = DrawMenuElementMouseIn(M);
	var YText = M.y + BoxHeight - FontAscent;

	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
	context.fillStyle = Selected?'white':bgcolor;
	context.fillRect(M.x-2, M.y, M.w + 4, BoxHeight);
	context.fillStyle = bgcolor;
	context.fillRect(M.x, M.y, M.w, BoxHeight);
	context.fillStyle = color;
	context.fillText(Name, M.x, YText);
	context.textAlign = 'right';
	context.fillText('' + Value, M.x + M.w - 2, YText);
	context.textAlign = 'left';
	M.cidx = 1-M.cidx;
	M.y += BoxHeight;
	return bMouseIn && MouseReleased;
}
function DrawMenuRoll(M, Name, RollValue, RollExt, RollFunction, Tweak, Type)
{
	var context = CanvasDetailedView.getContext('2d');

	var YText = M.y + BoxHeight - FontAscent;
	var SizeMinus = context.measureText('-').width;
	var SizePlus = context.measureText('+').width;

	var bMouseIn = MouseY >= M.y && MouseY < M.y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[M.cidx];
	context.fillStyle = bgcolor;
	context.fillRect(M.x-2, M.y, M.w+4, BoxHeight);
	context.fillStyle = 'white';
	context.fillText(Name, M.x, YText);
	context.textAlign = 'right';
	var XTemp = M.x + M.w - 3;

	if(KeyShiftDown && bMouseIn)
	{
		if(Tweak>=0)
		{
			RollFunction(0, MouseX-Tweak);
		}
		Tweak = MouseX;
		bMouseIn = false;
	}
	else
	{
		Tweak = -1;
	}

	var MouseReleasedUsed = false;
	if(bMouseIn && MouseX >= XTemp - SizePlus && MouseX <= XTemp)
	{
		context.fillStyle = 'red';
		if(MouseReleased)
		{
			RollFunction(1);
			MouseReleasedUsed = true;
		}
	}
	else
	{
		context.fillStyle = 'white';
	}
	context.fillText('+', XTemp, YText);
	XTemp -= SizePlus + 3;



	if(bMouseIn && MouseX >= XTemp - SizeMinus && MouseX <= XTemp)
	{
		context.fillStyle = 'red';
		if(MouseReleased)
		{
			RollFunction(-1);
			MouseReleasedUsed = true;
		}
	}
	else
	{
		context.fillStyle = 'white';
	}

	context.fillText('-', XTemp, YText);
	XTemp -= SizeMinus + 3;
	var RollText = ''+RollValue + RollExt;
	var RollWidth = context.measureText(RollText).width;
	context.fillStyle = 'white';

	context.fillText(RollText, XTemp, YText);
	XTemp -= RollWidth;

	context.textAlign = 'left';

	M.cidx = 1-M.cidx;

	M.y += BoxHeight;
	if(Type && MouseReleased && bMouseIn && !MouseReleasedUsed)
	{
		var V = ShowPrompt(Name, RollValue, Type);
		RollFunction(0,0,V);
	}
	return Tweak;

}
function CheckPopupAllowed()
{
	if(!PopupsAllowed && !PopupTestPending)
	{
		PopupTestPending = 1;
		PopupsAllowed = 0;
		PopupsFailed = 0;
		let DoPopupTest = function()
		{
			var W = window.open("about:blank");
			var Fail = function()
			{
				PopupTestPending = 0;
				PopupsFailed = 1;
				PopupsAllowed = 0;
			};
			var Check = function()
			{
				if(!(W.innerHeight>0))
					Fail();
				else
				{
					PopupTestPending = 0;
					PopupsFailed = 0;
					PopupsAllowed = 1;
					W.close();
				}
			};
			if(W)
			{
				if(/chrome/.test(navigator.userAgent.toLowerCase()))
					setTimeout(Check, 200);
				else
					W.onload = Check;
			}
			else
			{
				Fail();
			}
		};
		setTimeout(DoPopupTest, 5000);
	}
}

function GetSubGraphReferenceTime(SubGraphSettings, TimerState)
{
	if(SubGraphSettings.AutomaticReference)
	{
	 	return TimerState.historymaxsoft ? TimerState.historymax : TimerState.historymax;
	}
	else
	{
		return SubGraphSettings.ReferenceTime;
	}
}
function GetSubGraphSettingsKey(key)
{
	if(Settings.ViewActive == VIEW_GRAPH_PERCENTILE)
	{
		return "perc_"+key;
	}
	else
	{
		return key;
	}
}
function GetSubGraphSettings(key)
{
	let k = GetSubGraphSettingsKey(key);
	let SubGraphSettings = Settings.SubGraphSettings[k];
	if(!SubGraphSettings)
	{
		SubGraphSettings = {"ReferenceTime":10.0, "TargetTime":-1, "AutomaticReference":1, "Percentile":0.0};
		Settings.SubGraphSettings[k] = SubGraphSettings;
	}
	return SubGraphSettings;
}


function DrawMenuGraphSettings()
{
	let Percentile = Settings.ViewActive == VIEW_GRAPH_PERCENTILE;
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = (Percentile?3:2) * BoxHeight;
	let Strings = ["AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length"];
	let wLeft = MeasureArray(0, Strings);
	let wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
	let Width = wLeft + 35 + wRight;
	SizeInfo.w = Width;
	SizeInfo.x = CaptureButtonX;
	SizeInfo.y = CaptureButtonY;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);


	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", SubGraphSettings.ReferenceTime, '', ReferenceRollSubGraph, ReferenceTimeTweak, 'int');
	if(DrawMenuElement(M, SubGraphSettings.AutomaticReference, "Automatic Reference Time", SubGraphSettings.AutomaticReference, 'white'))
	{
		SubGraphSettings.AutomaticReference = 1-SubGraphSettings.AutomaticReference;
	}
	if(Percentile)
	{
		//PercentileTweak = DrawMenuRoll(M, "Percentile", SubGraphSettings.Percentile, '', PercentileRollSubGraph, PercentileTweak, 'int');
		if(DrawMenuElement(M, 0, "Clear Aggregate", "", 'white'))
		{
			let TimerMap = FrameData.TimerMap;
			if(TimerMap)
			{
				let TimerState = TimerMap[SubMenuGraphSettingsKey];
				TimerState.PercentileMax = -1e38;
				TimerState.PercentileMin = 1e38;
				TimerState.Percentile = new Float32Array(PERCENTILE_SAMPLES);
				TimerState.Percentile.fill(0.0);
				TimerState.PercentileCount = 0;
			}
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}


function DrawMenuGraph()
{
	let Selection = null;
	let SizeInfo = {};
	let NumColumns = 0;
	for(let key in CSVAllColumns)
		NumColumns++;
	SizeInfo.h = (NumColumns) * BoxHeight;
	let wLeft = 0;
	let wRight = MeasureObjectKeys(20, CSVAllColumns);

	let Width = wLeft + wRight;


	SizeInfo.w = Width;


	SizeInfo.x = GraphButtonX;
	SizeInfo.y = GraphButtonY;
	if(SizeInfo.y + SizeInfo.h > nHeight)
		SizeInfo.y = nHeight - SizeInfo.h;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);

	let GraphSet = Graphs[GraphButtonIndex];
	if(!GraphSet)
		debugger;

	for(let CName in CSVAllColumns)
	{
		let Active = GraphSet[CName] == 1;
		if(DrawMenuElement(M, Active, "", CName, 'white'))
		{
			if(KeyCtrlDown)
			{
				for(let CName2 in CSVAllColumns)
					GraphSet[CName2] = 0;
				GraphSet[CName] = 1;
			}
			else
			{
				if(Active)
					GraphSet[CName] = 0;
				else
					GraphSet[CName] = 1;
			}
			gGraphCSVInvalid = 1;
		}
	}
	SizeInfo.h = M.y - SizeInfo.y;

	RequestDraw();
	return SizeInfo;
}

function DrawMenuGraphMode()
{
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = 4 * BoxHeight;
	let Strings = ["Min/Max Region", "Average", "Min", "Max", "Percentil Min/Max Region", "Percentile Avg", "Percentile Min", "Percentile Max"];
	let wLeft = MeasureArray(0, Strings);
	let wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	let Width = wLeft + 35 + wRight;

	SizeInfo.w = Width;
	SizeInfo.x = GraphModeButtonX;
	SizeInfo.y = GraphModeButtonY;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);

	let Mask = 1;
	for(let i = 0; i < Strings.length; ++i)
	{
		let Active = 0 != (GraphModeMask&Mask);
		if(DrawMenuElement(M, Active, Strings[i], "", 'white'))
		{
			if(Active)
				GraphModeMask = GraphModeMask & ~Mask;
			else
				GraphModeMask = GraphModeMask | Mask;
			gGraphCSVInvalid = 1;
		}
		Mask = Mask << 1;
	}

	SizeInfo.h = M.y - SizeInfo.y;

	RequestDraw();
	return SizeInfo;



}




function Dots()
{
	let t = new Date().getMilliseconds() / 200;
	let dots = [".  ",".. ","...",".. "];
	let x = Math.floor(t) %4;
	return dots[x];
}


function DrawMenuCapture()
{
	let Selection = null;
	let SizeInfo = {};
	SizeInfo.h = 7 * BoxHeight;
	let Strings = ["Popups Allowed", "AutoCapture Enabled", "AutoCapture Threshold", "AutoCapture Source", "Capture Length", "Capture Delay"];
	let wLeft = MeasureArray(0, Strings);
	let wRight = 50;
	wRight = MeasureArray(wRight, ["Frame Time"]);
	wRight = MeasureArray(wRight, EnabledArray, function(a){return TimerArray[a].name; } );
	let Width = wLeft + 35 + wRight;
	SizeInfo.w = Width;
	SizeInfo.x = CaptureButtonX - SizeInfo.w;
	SizeInfo.y = CaptureButtonY - SizeInfo.h;

	let M = CreateMenuState(SizeInfo);
	let context = CanvasDetailedView.getContext('2d');
	context.fillRect(M.x, M.y, Width, SizeInfo.h);
	let d = Dots();
	let PopupStatus = PopupsAllowed ? "Yes" :  (PopupsFailed ? "No" : (PopupTestPending ? ("Testing"+d) : "Untested"));
	if(DrawMenuElement(M, 0, "Popups Allowed", PopupStatus, 'white', 0))
	{
		CheckPopupAllowed();
	}
	let AutoStatus = AutoCaptureEnabled > 0 ? "on" : "off";
	if(CaptureTriggerTime != null && CaptureTriggerTimeType == 2)
	{
		AutoStatus = "pending"+d;
	}
	if(DrawMenuElement(M, 0, "AutoCapture Enabled", AutoStatus, 'white', 0))
	{
		if(!AutoCaptureEnabled && CaptureTriggerTime == null)
		{
			if(Settings.CaptureDelay <= 0)
			{
				AutoCaptureEnabled = Settings.AutoCaptureRepeat > 0 ? Settings.AutoCaptureRepeat : 1;
			}
			else
			{
				CaptureTriggerTime = new Date();
				CaptureTriggerTimeType = 2;
			}
		}
		else
		{
			AutoCaptureEnabled = 0;
			if(CaptureTriggerTimeType == 2)
			{
				CaptureTriggerTimeType = 0;
				CaptureTriggerTime = null;
			}
		}
	}
	AutoCaptureSourceTweak = DrawMenuRoll(M, "AutoCapture Source", GetAutoCaptureString(), '', AutoCaptureSourceRoll, AutoCaptureSourceTweak);
	AutoCaptureTweak = DrawMenuRoll(M, "AutoCapture Threshold", Settings.AutoCaptureTheshold, 'ms', AutoCaptureRoll, AutoCaptureTweak, 'int');
	AutoCaptureRepeatTweak = DrawMenuRoll(M, "AutoCapture Repeat", Settings.AutoCaptureRepeat, '', AutoCaptureRepeatRoll, AutoCaptureRepeatTweak, 'int');
	CaptureTweak = DrawMenuRoll(M, "Capture Length",  Settings.CaptureFrames, '', CaptureRoll, CaptureTweak, 'int');
	CaptureDelayTweak = DrawMenuRoll(M, "Capture Delay",  Settings.CaptureDelay, '', CaptureDelayRoll, CaptureDelayTweak, 'int');

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;

}
function WindowRect(x,y,w,h)
{
	let s = {};
	s.x = x;
	s.y = y;
	s.w = w;
	s.h = h;
	return s;
}
function GetAggregateString()
{
	if(0 == Settings.AggregateFrames)
		return 'infinite';
	else
		return Settings.AggregateFrames + '';
}

function AggregateRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect || SetDirect == 0)
	{
		if(SetDirect <= 0 || SetDirect == 'infinite')
		{
			Settings.AggregateFrames = 0;
		}
		else
		{
			Settings.AggregateFrames = SetDirect;
		}
	}
	else if(Tweak)
	{
		Settings.AggregateFrames = TweakValue(Settings.AggregateFrames, Tweak, 0.98, 0, 500);

	}
	else if(Direction)
	{
		Settings.AggregateFrames = NextValue(AggregatePresets, Settings.AggregateFrames, Direction);
	}
}
function ReferenceRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.ReferenceTime = SetDirect;
	}
	else if(Tweak)
	{
		Settings.ReferenceTime = TweakValue(Settings.ReferenceTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		Settings.ReferenceTime = NextValue(ReferencePresets, Settings.ReferenceTime, Direction);
	}
}

function ReferenceRollSubGraph(Direction, Tweak, SetDirect)
{
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
	if(SetDirect)
	{
		SubGraphSettings.ReferenceTime = SetDirect;
	}
	else if(Tweak)
	{
		SubGraphSettings.ReferenceTime = TweakValue(SubGraphSettings.ReferenceTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		SubGraphSettings.ReferenceTime = NextValue(ReferencePresets, SubGraphSettings.ReferenceTime, Direction);
	}
}

function PercentileRollSubGraph(Direction, Tweak, SetDirect)
{
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
	if(SetDirect)
	{
		SubGraphSettings.Percentile = SetDirect;
	}
	else if(Tweak)
	{
		SubGraphSettings.Percentile = TweakValue(SubGraphSettings.Percentile, Tweak, 0.98, 5, 1000);
	}
	else if(Direction)
	{
		SubGraphSettings.Percentile = NextValue(PercentilePresets, SubGraphSettings.Percentile, Direction);
	}
}


function TargetRoll(Direction, Tweak, SetDirect)
{
	if(SetDirect)
	{
		Settings.TargetTime = SetDirect;
	}
	else if(Tweak)
	{
		Settings.TargetTime = TweakValue(Settings.TargetTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		Settings.TargetTime = NextValue(ReferencePresets, Settings.TargetTime, Direction);
	}
}
function TargetRollSubGraph(Direction, Tweak, SetDirect)
{
	let SubGraphSettings = GetSubGraphSettings(SubMenuGraphSettingsKey);
	if(SetDirect)
	{
		SubGraphSettings.TargetTime = SetDirect;
	}
	else if(Tweak)
	{
		SubGraphSettings.TargetTime = TweakValue(SubGraphSettings.TargetTime, Tweak, 0.98, 5, 1000);

	}
	else if(Direction)
	{
		SubGraphSettings.TargetTime = NextValue(ReferencePresets, SubGraphSettings.TargetTime, Direction);
	}
}
function DrawMenuSettings()
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = AggregateMenuSize();
	SizeInfo.x = MenuItems[SubMenuSettings].x;
	SizeInfo.y = MenuItems[SubMenuSettings].y;

	SizeInfo.w = 200;
	var M = CreateMenuState(SizeInfo);

	AggregateTweak = DrawMenuRoll(M, "Aggregate Frames", GetAggregateString(), '', AggregateRoll, AggregateTweak, 'int');
	ReferenceTimeTweak = DrawMenuRoll(M, "Reference Time", Settings.ReferenceTime, '', ReferenceRoll, ReferenceTimeTweak, 'int');
	TargetTimeTweak = DrawMenuRoll(M, "Target Time", Settings.TargetTime, '', TargetRoll, TargetTimeTweak, 'int');
	if(DrawMenuElement(M, Settings.AutomaticReference, "Automatic Reference Time", Settings.AutomaticReference, 'white'))
	{
		Settings.AutomaticReference = 1-Settings.AutomaticReference;
	}
	if(DrawMenuElement(M, Settings.ViewCompressed, "Compressed View", Settings.ViewCompressed, 'white'))
	{
		Settings.ViewCompressed = 1-Settings.ViewCompressed;
		ResizeCanvas();
	}

	if(Settings.AggregateFrames <= 0)
	{
		if(DrawMenuElement(M, 0, "Clear Aggregate", "Current[" + AggregateCurrent + "]", 'white'))
		{
			WSSendMessage("r");
		}
	}
	if(DrawMenuElement(M, 0, "Clear Percentile Aggregate", "", 'white'))
	{
		let TimerMap = FrameData.TimerMap;
		if(TimerMap)
		{
			for(let key in TimerMap)
			{
				let idx = GetTimer(key);
				let TimerState = TimerMap[key];
				if(!IsGroup(key) && TimerState.Percentile)
				{
					TimerState.PercentileMax = -1e38;
					TimerState.PercentileMin = 1e38;
					TimerState.Percentile = new Float32Array(PERCENTILE_SAMPLES);
					TimerState.Percentile.fill(0.0);
					TimerState.PercentileCount = 0;
				}
			}
		}
	}


	if(DrawMenuElement(M, Settings.AllowHighDPI, "Allow High DPI", Settings.AllowHighDPI, 'white'))
	{
		Settings.AllowHighDPI = 1 - Settings.AllowHighDPI;
		ResizeCanvas();
	}
	if(DrawMenuElement(M, Cookie.CodeReportMode == 0, "Code Report: Prompt", Cookie.CodeReportMode == 0 ? 1 : 0, 'white'))
	{
		Cookie.CodeReportMode = 0;
		WriteCookie();
	}

	if(DrawMenuElement(M, Cookie.CodeReportMode == 1, "Code Report: Report Silently", Cookie.CodeReportMode == 1 ? 1 : 0, 'white'))
	{
		Cookie.CodeReportMode = 1;
		WriteCookie();
	}
	if(DrawMenuElement(M, Cookie.CodeReportMode == 2, "Code Report: Never Report", Cookie.CodeReportMode == 2 ? 1 : 0, 'white'))
	{
		Cookie.CodeReportMode = 2;
		WriteCookie();
	}

	SizeInfo.h = M.y - SizeInfo.y;
	return SizeInfo;
}

function MoveFilterInputDiv(x, y, w)
{
	if(FilterInputDivPos.x != x || FilterInputDivPos.y != y || FilterInputDivPos.w != w)
	{
		FilterInputDivPos.x = x;
		FilterInputDivPos.y = y;
		FilterInputDivPos.w = w;
		FilterInputDiv.style['left'] = x + 'px';
		FilterInputDiv.style['top'] = y + 'px';
		FilterInput.style['width'] = w + 'px';
	}
}

function DrawMenuTimer()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuTimers = 0;
	}
	FilterInputValueLast = FilterInput.value;
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize();
	SizeInfo.x = MenuItems[SubMenuTimers].x;
	SizeInfo.y = MenuItems[SubMenuTimers].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	var Selection = null;
	var X = SizeInfo.x;
	MoveFilterInputDiv(SizeInfo.x, SizeInfo.y, SizeInfo.w);
	Y += 35;

	var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bMouseInClear =  MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var YStart = Y;

	var MouseTaken = bMouseIn;

	Y += BoxHeight;
	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuTimers;

	for(var i = 0; i < TimerArray.length; ++i)
	{
		var v = TimerArray[i];
		if(v.idtype == TYPE_TIMER
		 //|| v.idtype == TYPE_GROUP
		 )
		{
			var Name = v.name;
			var ParentName = TimerArray[v.parent].name;
			if(FilterMatch(FilterArray, ParentName + " " + Name) && (0 == TimersActiveOnly || v.e))
			{
				if(Y > YStart)
				{
					var ParentColor = TimerArray[v.parent].e ? 'white' : 'grey';
					bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && !MouseTaken;
					bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
					TextY = Y+BoxHeight-FontAscent;
					context.fillStyle = v.e?'white':bgcolor;
					context.fillRect(X-2, Y, Width+4, BoxHeight);
					context.fillStyle = bgcolor;
					context.fillRect(X, Y, Width, BoxHeight);
					context.fillStyle = ParentColor;
					context.fillText(ParentName, X + 2, TextY);
					context.fillStyle = v.color;
					context.textAlign = 'right';
					context.fillText(Name, X + Width - 2, TextY);
					context.textAlign = 'left';
					if(bMouseIn)
					{
						Selection = v.id;
					}
				}
				Y += BoxHeight;
				nColorIndex = 1-nColorIndex;
			}
		}
	}

	{

		var c0 = nBackColorOffset;
		var c1 = nBackColors[1];
		var W = Width + 4;
		var WHalf = W / 2;
		var InsideClear = bMouseInClear && MouseX-X< WHalf-1;
		var InsideActive =  bMouseInClear && MouseX-X > WHalf+1;
		context.fillStyle = nBackColors[0];
		context.fillRect(X-2, YClear, W, BoxHeight);

		context.fillStyle = InsideClear ? c0 :c1;
		context.fillRect(X-2, YClear, WHalf-1, BoxHeight);
		context.fillStyle = InsideActive ? c0 :c1;
		context.fillRect(X-2 + WHalf + 1, YClear, WHalf-1, BoxHeight);


		context.fillStyle = 'white';
		context.textAlign = 'center';
		context.fillText("[clear] ", X + 2 + Width * 0.25, TextYClear);
		context.fillStyle = TimersActiveOnly ? 'white' : 'grey';
		context.fillText("[active only]", X + 2 + Width * 0.75, TextYClear);
		if(MouseReleased)
		{
			if(InsideActive)
			{
				TimersActiveOnly = 1-TimersActiveOnly;
			}
			if(InsideClear)
			{
				WSSendMessage("x");
			}
		}
	}
	context.textAlign = 'left';
	if(Selection && MouseReleased && !MouseTaken)
	{
		WSSendMessage("c" + Selection);
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}

var LoadSymbolAnim = -1;
function LoadSymbolAnimRestart()
{
	if(LoadSymbolAnim > 0)
	{
		LoadSymbolAnim += 1;
	}
	else
	{
		LoadSymbolAnim = 1;
	}
}
function LoadSymbolAnimUpdateAndGet()
{
	if(LoadSymbolAnim>=0)
	{
		LoadSymbolAnim -= 0.03;
		if(LoadSymbolAnim < 0)
		{
			LoadSymbolAnim = -1;
		}
		else
		{
			return Math.sin(3.14  * LoadSymbolAnim);
		}

	}
	return -1;
}


var CircleSteps = 30;
var CircleX = Array(CircleSteps);
var CircleY = Array(CircleSteps);
function InitCircle()
{
	var twopi = 2 * Math.PI;
	for(var i = 0; i < CircleSteps; ++i)
	{
		var s = (1.0*i) / CircleSteps;

		var f = (1.0 * s) * twopi;
		CircleX[i] = Math.sin(f);
		CircleY[i] = Math.cos(f);
	}
}
function SpinnerResize(Spinner, w, h)
{
	if(h != Spinner.CanvasH || w != Spinner.CanvasW || DPR != Spinner.CanvasDPR)
	{
		Spinner.Canvas.style.width = w + 'px';
		Spinner.Canvas.style.height = h + 'px';
		Spinner.Canvas.width = w * DPR;
		Spinner.Canvas.height = h * DPR;
		Spinner.Canvas.getContext('2d').scale(DPR, DPR);
		Spinner.CanvasBack.style.width = w + 'px';
		Spinner.CanvasBack.style.height = h + 'px';
		Spinner.CanvasBack.width = w * DPR;
		Spinner.CanvasBack.height = h * DPR;

		Spinner.CanvasBack.getContext('2d').scale(DPR, DPR);
		Spinner.CanvasH = h;
		Spinner.CanvasW = w;
		Spinner.CanvasDPR = DPR;
	}
}
function SpinnerCircle(Phase0, Shift0, Phase1, Shift1, Phase2, Shift2)
{
	return {"Phase0" : Phase0, "Shift0": Shift0, "Phase1":Phase1, "Shift1":Shift1, "Phase2": Phase2, "Shift2": Shift2, "Q": 0, "QQ": 0, "A0":0, "A1":0, "A2":0};
}

function SpinnerInit(Blur, Color)
{
	var Spinner = {};
	Spinner.x = 0;
	Spinner.y = 0;
	Spinner.Canvas = document.createElement('canvas');
	Spinner.CanvasBack = document.createElement('canvas');
	Spinner.CanvasOffscreenData;
	Spinner.CanvasW = -1;
	Spinner.CanvasH = -1;
	Spinner.CanvasDPR = -1;
	Spinner.Circles = [];
	var x = 1 / 4;
	var y = 0.07;
	Spinner.Circles.push(SpinnerCircle(x, 0, y, 0, 0.0, 0.25));
	Spinner.Circles.push(SpinnerCircle(2/4, 0, 0, 0, 0.14, 0.25));
	Spinner.Fade = 0;
	Spinner.Blur = Blur;
	Spinner.Color = Color;
	return Spinner;
}

var SpinnerCorner = SpinnerInit(0.8, 'white');
var SpinnerLoadButton = SpinnerInit(0, 'white');
var SpinnerText1 = SpinnerInit(0.0, 'red');
var SpinnerText0 = SpinnerInit(0.0, 'red');


function SpinnerShow()
{
	return SymbolState != null && (SymbolState.q == 1 || SymbolState.r != SymbolState.f || FunctionQueryLastRequest != FunctionQueryReceived);
}

function SpinnerDraw(Enable, context, Spinner, X, Y, w, h)
{
	SpinnerResize(Spinner, w, h);
	var ContextSpinner = Spinner.Canvas.getContext('2d');


	var now = Date.now();
	if(!ContextSpinner.last)
	{
		ContextSpinner.last = now;
	}
	var DT = now - ContextSpinner.last;
	ContextSpinner.last = now;
	if(Enable)
	{
		Spinner.Fade += DT / 200;
	}
	else
	{
		Spinner.Fade -= DT / 1000;
	}
	Spinner.Fade = Math.max(0, Spinner.Fade);
	Spinner.Fade = Math.min(1, Spinner.Fade);
	var F = Spinner.Fade * Spinner.Fade;

	if(Spinner.Fade <= 0)
		return;
	ContextSpinner.clearRect(0, 0, w, h);
	if(Spinner.Blur > 0)
	{
		ContextSpinner.globalAlpha = Spinner.Blur;
		ContextSpinner.drawImage(Spinner.CanvasBack, 0, 0, w, h);
		ContextSpinner.globalAlpha = 1.0;
	}
	var twopi = 2 * Math.PI;
	for(var jjj = 0; jjj < Spinner.Circles.length; ++jjj)
	{
		var C = Spinner.Circles[jjj];
		InitCircle();
		var xs = CircleX;
		var ys = CircleY;
		var scale = (w-2) / 2;
		var offset = (w) / 2;
		var SPEED = 100.0;

		var angle = (C.Q / SPEED) * twopi;

		var QQSPEED = 1000;

		C.A0 += (twopi * DT / 1000.0) * C.Phase0;
		if(C.A0 > twopi)
			C.A0 -= twopi;
		C.A1 += (twopi * DT / 1000.0) * C.Phase1;
		if(C.A1 > twopi)
			C.A1 -= twopi;
		C.A2 += (twopi * DT / 1000.0) * C.Phase2;
		if(C.A2 > twopi)
			C.A2 -= twopi;

		var A0 = C.A0 + twopi * C.Shift0;
		var A1 = C.A1 + twopi * C.Shift1;
		var A2 = C.A2 + twopi * C.Shift2;
		var m = Math.cos(A0);
		var m0 = Math.sin(A2);
		var cs = Math.cos(A1);
		var ss = Math.sin(A1);
		for(var i = 0; i < xs.length; ++i)
		{
			var x = xs[i] * m;
			var y = ys[i] * m0;
			xs[i] = cs * scale * x - ss * scale * y;
			ys[i] = ss * scale * x + cs * scale * y;
			xs[i] += offset;
			ys[i] += offset;
		}
		ContextSpinner.strokeStyle = Spinner.Color;
		ContextSpinner.beginPath();
		ContextSpinner.moveTo(xs[0], ys[0]);
		for(var i = 1; i < CircleSteps; ++i)
		{
			ContextSpinner.lineTo(xs[i], ys[i]);
		}
		ContextSpinner.lineTo(xs[0], ys[0]);
		ContextSpinner.stroke();


	}
	context.globalAlpha = F;
	context.drawImage(Spinner.Canvas, X, Y, w, h);
	context.globalAlpha = 1;
	var tmp = Spinner.CanvasBack;
	Spinner.CanvasBack = Spinner.Canvas;
	Spinner.Canvas = tmp;
}


function DrawMenuPatched()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuPatched = 0;
	}

	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize();
	SizeInfo.x = MenuItems[SubMenuPatched].x;
	SizeInfo.y = MenuItems[SubMenuPatched].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	Width = Math.max(300, Width);
	Width = 10+ MeasureArray(Width, FunctionsInstrumented, function(s, i){return s + " " + FunctionsInstrumentedModule[i];} );

	if(Width + SizeInfo.x + 50 > nWidth)
	{
		Width = nWidth - (SizeInfo.x+50);
	}
	SizeInfo.w = Width;
	var MaxStringLength = Math.floor(Width/(FontWidth));

	var Selection = null;
	var X = SizeInfo.x;
	context.fillStyle = nBackColors[0];
	TextY = Y+BoxHeight-FontAscent;
	context.fillRect(X, Y, Width, BoxHeight);

	var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && MouseX-X < 100;
	context.fillRect(X, Y, 99, BoxHeight);
	context.textAlign = 'center';
	context.fillStyle = 'white';
	context.fillText("Patched functions", X + Width/2, TextY);

	Y += BoxHeight;
	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
	Y += 45;

	bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var bgcolorClear = bgcolor;
	var YStart = Y-BoxHeight*2;

	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuFunctions + 10;
	var Selection = -1;

	var StringColor = function(Name)
	{
		var h = StringHash(Name);
		var cidx = h % 360;
		return cidx;
	};

	var GetColor = function(Str)
	{
		var cidx = StringColor(Str);
		return "hsl(" + cidx + ",50%, 70%)";
	};
	for(var i = 0; i < FunctionsInstrumented.length; ++i)
	{
		var Name = FunctionsInstrumented[i];
		var ModuleName = FunctionsInstrumentedModule[i];
		if(FilterMatch(FilterArray, ModuleName + " " + Name))
		{

			var Color = GetColor(Name);
			var ColorModule = GetColor(Name);
			if(Y >= YStart)
			{
				bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
				bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
				TextY = Y+BoxHeight-FontAscent;

				context.fillStyle = bgcolor;
				context.fillRect(X, Y, Width, BoxHeight);
				context.fillStyle = Color;
				context.textAlign = 'right';
				context.fillText(Name, X + Width - 2, TextY);
				context.textAlign = 'left';
				context.fillStyle = ColorModule;
				context.fillText(ModuleName, X, TextY);
			}
			Y += BoxHeight;
			nColorIndex = 1-nColorIndex;
		}
	}
	context.textAlign = 'left';
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}


function DrawMenuModules()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuModules = 0;
	}
	FilterInputValueLast = FilterInput.value;
	var M = ModuleState;
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize(); //broken, fix!

	SizeInfo.x = MenuItems[SubMenuModules].x;
	SizeInfo.y = MenuItems[SubMenuModules].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	Width = Math.max(300, Width);
	Width = 10+ MeasureArray(Width, M, function(s){return s.n + " " + s.s;} );

	if(Width + SizeInfo.x + 50 > nWidth)
	{
		Width = nWidth - (SizeInfo.x+50);
	}
	SizeInfo.w = Width;


	var MaxStringLength = Math.floor(Width/(FontWidth));


	var X = SizeInfo.x;
	DrawSymbolHeaderMenu(context, X, Y, Width);

	Y += BoxHeight;
	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
	Y += 45;

	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var bgcolorClear = bgcolor;
	var YStart = Y-BoxHeight*2;

	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuModules + 10;
	var Selection = -1;

	var StringColor = function(Name)
	{
		var h = StringHash(Name);
		var cidx = h % 360;
		return cidx;
	};

	for(var i = 0; i < M.length; ++i)
	{
		var Name = M[i].n;
		var Count = M[i].s;
		var Prc = M[i].p;
		if(Prc<0||Prc>1)
			Prc = 0;
		let cidx = StringColor(Name);
		let Color = "hsl(" + cidx + ",50%, 70%)";
		let C1 = "hsl(" + cidx + ",30%, 40%)";
		var N = Name;
		if(N.length > MaxStringLength)
		{
			N = N.substring(N.length - MaxStringLength);
		}
		if(FilterMatch(FilterArray, Name))
		{

			if(Y >= YStart)
			{
				bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
				bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
				TextY = Y+BoxHeight-FontAscent;

				context.fillStyle = bgcolor;
				context.fillRect(X, Y, Width, BoxHeight);
				if(Prc>0 && Prc <= 1)
				{
					context.fillStyle = C1;
					context.fillRect(X, Y, Prc*Width, BoxHeight);
				}
				context.fillStyle = 'white';
				context.textAlign = 'right';
				context.fillText(Count + '', X + Width - 2, TextY);
				context.textAlign = 'left';
				context.fillStyle = Color;
				context.fillText(N, X, TextY);
				if(bMouseIn)
				{
					Selection = i;
				}
			}
			Y += BoxHeight;
			nColorIndex = 1-nColorIndex;
		}
	}
	context.textAlign = 'left';
	if(Selection != -1 && MouseReleased)
	{
		WSSendMessage("L" + M[Selection].n);
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}
function DrawSymbolHeaderMenu(context, X, Y, Width)
{
	context.fillStyle = nBackColors[0];
	let TextY = Y+BoxHeight-FontAscent;
	context.fillRect(X+100, Y, Width-100, BoxHeight);
	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight && MouseX-X < 100;
	if(bMouseIn)
	{
		context.fillStyle = nBackColorOffset;
	}

	context.fillRect(X, Y, 99, BoxHeight);


	let NumSymbols = 0;
	let SymbolStateString = "Load all";
	let SymbolButtonActive = 1;
	let SymbolSpinnerActive = 0;
	let FinishedSymbols = 0;
	if(SymbolState)
	{
		FinishedSymbols = SymbolState.f;
		var s = SymbolState.s;
		NumSymbols = SymbolState.l;
		SymbolButtonActive = 1;
		if(SymbolState.q == 1 || FunctionQueryLastRequest != FunctionQueryReceived)
		{
			SymbolStateString = "Querying";
			SymbolButtonActive = 0;
			SymbolSpinnerActive = 1;
		}
		else if(SymbolState.f != SymbolState.r)
		{
			SymbolButtonActive = 0;
			SymbolSpinnerActive = 1;
			SymbolStateString = "Loading";
		}
		else if(SymbolState.f == ModuleState.length)
		{
			SymbolButtonActive = 0;
			SymbolStateString = "Loaded";
		}
	}
	let LoadButtonAnimation  = LoadSymbolAnimUpdateAndGet();

	context.textAlign = 'right';
	context.fillStyle = 'white';
	context.fillText(NumSymbols + " Symbols " + FinishedSymbols + "/" + ModuleState.length + " Modules", X+Width-2, TextY);
	context.textAlign = 'center';

	if(LoadButtonAnimation>0)
	{
		var c = "hsl(0,0%," + (LoadButtonAnimation * 100)+"%)";
		context.fillStyle = c;
	}
	if(SymbolButtonActive)
	{
		if(bMouseIn && MouseReleased)
		{
			WSSendMessage("S"); //load symbols
		}
		context.fillText(SymbolStateString, X + 50, TextY);
	}
	else
	{
		context.fillStyle = 'grey';
		context.fillText(SymbolStateString, X + 50, TextY);
	}
	SpinnerDraw(SymbolSpinnerActive, context, SpinnerLoadButton, X+2, Y,  FontHeight, FontHeight );


}

function DrawMenuFunctions()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuFunctions = 0;
		var m = FilterInput.value.trim();
		if(m != "")
		{
			if(SymbolState && SymbolState.r == SymbolState.f)
			{
				var Req = ++FunctionQueryLastRequest;
				var Q = "q" + Req + "x" + m;
				WSSendMessage(Q);
				FunctionQueryPending = null;
			}
			else
			{
				FunctionQueryPending = m;
				if(SymbolState) //wtf?
				{
					LoadSymbolAnimRestart();
				}
			}
		}
	}

	FilterInputValueLast = FilterInput.value;
	var FF = FunctionQueryArray;
	var FilterArray = CreateFilter(FilterInput.value);
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var SizeInfo = TimerMenuSize(); //broken, fix
	SizeInfo.x = MenuItems[SubMenuFunctions].x;
	SizeInfo.y = MenuItems[SubMenuFunctions].y;
	var Y = SizeInfo.y;
	var Width = SizeInfo.w;
	Width = Math.max(300, Width);
	Width = 10+ MeasureArray(Width, FF, function(s){return s.n + " " + s.m;} );

	if(Width + SizeInfo.x + 50 > nWidth)
	{
		Width = nWidth - (SizeInfo.x+50);
	}
	SizeInfo.w = Width;
	var MaxStringLength = Math.floor(Width/(FontWidth));

	var Selection = null;
	var X = SizeInfo.x;

	{
		DrawSymbolHeaderMenu(context, X, Y, Width);
	}


	Y += BoxHeight;
	MoveFilterInputDiv(SizeInfo.x, Y, SizeInfo.w-6);
	Y += 45;

	let bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
	var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
	var TextY = Y+BoxHeight-FontAscent;
	var YClear = Y;
	var TextYClear = TextY;
	var bgcolorClear = bgcolor;
	var YStart = Y-BoxHeight*2;

	nColorIndex = 1-nColorIndex;

	Y -= nOffsetMenuFunctions + 10;
	var Selection = -1;

	var StringColor = function(Name)
	{
		var h = StringHash(Name);
		var cidx = h % 360;
		return cidx;
	};

	for(var i = 0; i < FF.length; ++i)
	{
		if(true)
		{
			var Name = FF[i].n;
			var ShortName = FF[i].sn;
			var Color = FF[i].c;
			var ColorModule = FF[i].cm;
			var ModuleName = FF[i].m;
			if(!Color || !ColorModule)
			{
				var cidx = StringColor(ShortName);
				FF[i].c = "hsl(" + cidx + ",50%, 70%)";
				FF[i].rgb = ConvertHslToRGB(cidx/ 360, 0.5, 0.7);
				var cidxModule = StringColor(ModuleName);
				FF[i].cm = "hsl(" + cidxModule + ",50%, 70%)";
				FF[i].rgbm = ConvertHslToRGB(cidxModule/ 360, 0.5, 0.7);
				Color = FF[i].c;
				ColorModule = FF[i].cm;
			}
			var UseAlt = 0;
			var N = UseAlt ? Name : ShortName;
			if(N.length > MaxStringLength)
			{
				N = N.substring(N.length - MaxStringLength);
			}
			var E = false;
			if(true)
			{

				if(Y >= YStart)
				{
					bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
					bgcolor = bMouseIn && MouseX > X ? nBackColorOffset : nBackColors[nColorIndex];
					TextY = Y+BoxHeight-FontAscent;

					context.fillStyle = bgcolor;
					context.fillRect(X, Y, Width, BoxHeight);
					context.fillStyle = Color;
					context.textAlign = 'right';
					context.fillText(N, X + Width - 2, TextY);
					context.textAlign = 'left';
					context.fillStyle = ColorModule;
					context.fillText(ModuleName, X, TextY);
					if(bMouseIn)
					{
						context.fillStyle = Color;
						var bgcolorin = bMouseIn && MouseX < X ? nBackColorOffset : nBackColors[nColorIndex];

						Selection = i;
						var W = context.measureText('>>').width;
						W = Math.max(W, BoxHeight) + 2;
						var Corner = X - W - 1;
						if(Corner < SizeInfo.x)
						{
							SizeInfo.w += SizeInfo.x - Corner;
							SizeInfo.x = Corner;
						}
						context.fillStyle = bgcolorin;
						context.fillRect(Corner, Y, W, BoxHeight);
						context.fillStyle = Color;
						context.textAlign = 'center';
						context.fillText(">>", Corner + Math.floor(W / 2), TextY);

						context.textAlign = 'left';
					}
				}
				Y += BoxHeight;
				nColorIndex = 1-nColorIndex;
			}
		}
	}

	context.textAlign = 'left';
	if(Selection != -1 && MouseReleased)
	{
		if(KeyShiftDown || MouseX < X)
		{
			WSSendMessage("I" + FF[Selection].a + ' ' + FF[Selection].rgb + ' ' + FF[Selection].m + '!' + FF[Selection].n);
		}
		else
		{
			WSSendMessage("i" + FF[Selection].a + ' ' + FF[Selection].rgb + ' ' + FF[Selection].m + '!' + FF[Selection].n);
		}
	}
	SizeInfo.h = Y-SizeInfo.y;
	return SizeInfo;
}

function DrawMenuGeneric(Elements, Active, OnClick, x, y, Elements2)
{
	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	if(Elements2.length != Elements.length)
	{
		Elements2 = null;
	}

	var h = FontHeight * Elements.length;
	var w = 20;
	var w2 = 0;
	for(var i = 0; i < Elements.length; ++i)
	{
		var m = context.measureText(Elements[i]).width;
		w = w > m ? w : m;
		if(Elements2)
		{
			m = context.measureText(Elements2[i]).width;
			w2 = w2 > m ? w2 : m;
		}
	}
	w += 10 + w2;
	var SizeInfo = MenuSize(w);
	SizeInfo.x = x;
	SizeInfo.y = y;
	var X = x;
	var Y = y;


	for(var i = 0; i < Elements.length; ++i)
	{
		var Selected = Active == i;
		var Name = Elements[i];
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		var TextY = Y+BoxHeight-FontAscent;
		context.fillStyle = Selected?'white':bgcolor;
		context.fillRect(X-2, Y, w+4, BoxHeight);
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, w, BoxHeight);
		context.fillStyle = 'white';
		context.fillText(Name, X + 2, TextY);
		if(Elements2)
		{
			context.textAlign = "right";
			context.fillText(Elements2[i], X + w , TextY);
			context.textAlign = "left";
		}
		context.fillText(Name, X + 2, TextY);
		if(bMouseIn && MouseReleased)
		{
			OnClick(i, Name);
		}
		Y += BoxHeight;
		nColorIndex = 1-nColorIndex;
	}
	SizeInfo.h = Y - SizeInfo.y;
	return SizeInfo;
}

function DrawMenuGroup()
{
	if(FilterInputValueLast != FilterInput.value)
	{
		nOffsetMenuGroup = 0;
	}
	FilterInputValueLast = FilterInput.value;

	var context = CanvasDetailedView.getContext('2d');
	var nColorIndex = 0;
	var Selection = null;
	var SizeInfo = GroupMenuSize();
	SizeInfo.x = MenuItems[SubMenuGroup].x;
	SizeInfo.y = MenuItems[SubMenuGroup].y;
	var Y = SizeInfo.y;
	var X = SizeInfo.x;
	var Width = SizeInfo.w;
	var FilterArray = CreateFilter(FilterInput.value);
	MoveFilterInputDiv(SizeInfo.x-2, SizeInfo.y, SizeInfo.w-1);
	var YStart = Y+20;
	Y += 35;
	Y -= nOffsetMenuGroup;


	function DrawMenuElement(Selected, Name, color, Indent)
	{
		var bMouseIn = MouseY >= Y && MouseY < Y + BoxHeight;
		var bgcolor = bMouseIn ? nBackColorOffset : nBackColors[nColorIndex];
		context.fillStyle = Selected?'white':bgcolor;
		context.fillRect(X-2, Y, Width+4, BoxHeight);
		context.fillStyle = bgcolor;
		context.fillRect(X, Y, Width, BoxHeight);
		context.fillStyle = color;
		if(!Indent) Indent = 0;
		context.fillText(Name, X + Indent*FontWidth, Y+BoxHeight-FontAscent);
		nColorIndex = 1-nColorIndex;
		Y += BoxHeight;
		return bMouseIn;
	}
	function DrawMenuRecursive(Index, Indent, categorymatch)
	{
		ProfileEnter("DrawMenuRecursive");
		var v = TimerArray[Index];
		if(v.idtype == TYPE_TIMER || v.idtype == TYPE_COUNTER)
		{
			return;
		}
		if(v.idtype == TYPE_GROUP && !categorymatch)
		{
			if(!FilterMatch(FilterArray, v.name))
			{
				return;
			}
		}
		var catmatch = 0;
		if(v.idtype == TYPE_CATEGORY)
		{
			if(FilterMatch(FilterArray, v.name))
			{
				catmatch = 1;
			}
		}
		var Closed = 0;
		if(Index > 0)
		{
			if(Y > YStart)
			{
				if(DrawMenuElement(v.e, v.name, v.color, Indent))
				{
					Selection = v.id;
				}
			}
			else
			{
				Y += BoxHeight;
			}
		}

		if(!Closed)
		{
			var ChildIndex = v.firstchild;
			while(ChildIndex != -1)
			{
				DrawMenuRecursive(ChildIndex, Indent + 1, catmatch);
				ChildIndex = TimerArray[ChildIndex].sibling;
			}
		}
		ProfileLeave();
	}
	DrawMenuRecursive(0, -1);
	if(Selection && MouseReleased)
	{
		WSSendMessage("c" + Selection);
	}
	SizeInfo.h = Y - SizeInfo.y;
	return SizeInfo;
}

function ShowMenu()
{
	if(!Settings.ViewCompressed)
		return true;
	else
	{
		var Time = new Date();
		var Delta = Time - MouseMoveTime;
		console.log('delta time is ' + Delta);
		return Delta < 2000;
	}
}

function DrawMenu()
{
	//if(WSConnected && WS && WS.readyState == 1)
	{
		var context = CanvasDetailedView.getContext('2d');
		var nColorIndex = 0;
		var Y = 50;
		var Width = 300;
		var Selection = null;
		if(!ShowMenu())
		{
			return;
		}
		ProfileEnter("DrawMenu");
		DrawTopMenu();
		var MenuRect = WindowRect(0,0,nWidth,nHeight);
		if(SubMenuActive != -1)
		{
			MouseMoveTime = new Date();
		}
		if(SubMenuActive == SubMenuGroup)
		{
			MenuRect = DrawMenuGroup();
		}
		else if(SubMenuActive == SubMenuTimers)
		{
			MenuRect = DrawMenuTimer();
		}
		else if(SubMenuActive == SubMenuModules)
		{
			MenuRect = DrawMenuModules();
		}
		else if(SubMenuActive == SubMenuFunctions)
		{
			MenuRect = DrawMenuFunctions();
		}
		else if(SubMenuActive == SubMenuPatched)
		{
			MenuRect = DrawMenuPatched();
		}
		else if(SubMenuActive == SubMenuSettings)
		{
			MenuRect = DrawMenuSettings();
		}
		else if(SubMenuActive == SubMenuViews)
		{
			MenuRect = DrawMenuViews();
		}
		else if(SubMenuActive == SubMenuPresets)
		{
			MenuRect = DrawMenuPresets();
		}
		else if(SubMenuActive == SubMenuColumns)
		{
			MenuRect = DrawMenuColumns();
		}
		else if(SubMenuActive == SubMenuCapture)
		{
			MenuRect = DrawMenuCapture();
		}
		else if(SubMenuActive == SubMenuGraphSettings)
		{
			MenuRect = DrawMenuGraphSettings();
		}
		else if(SubMenuActive == SubMenuGraph)
		{
			MenuRect = DrawMenuGraph();
		}
		else if(SubMenuActive == SubMenuGraphMode)
		{
			MenuRect = DrawMenuGraphMode();
		}




		var Grow = 10;
		MenuRect.x -= Grow;
		MenuRect.y -= Grow;
		MenuRect.h += 2*Grow;
		MenuRect.w += 2*Grow;
		var MouseMoved = MouseX != SubMenuMouseX || MouseY != SubMenuMouseY;

		if(MouseInRect(MenuRect) || !MouseMoved)
		{
			SubMenuTimeout = new Date();
			SubMenuMouseX = MouseX;
			SubMenuMouseY = MouseY;
		}
		else
		{
			var Time = new Date() - SubMenuTimeout;
			var Dest = SubMenuTimeoutBase * 1000;
			if(Time > Dest)
			{
				EnableMenu(-1);
			}
		}
		if(0)//debugging of menu extents. dont delete
		{
			context.strokeStyle = 'red';
			context.beginPath();
			context.moveTo(MenuRect.x,MenuRect.y);
			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y);
			context.lineTo(MenuRect.x + MenuRect.w,MenuRect.y+MenuRect.h);
			context.lineTo(MenuRect.x,MenuRect.y+MenuRect.h);
			context.lineTo(MenuRect.x,MenuRect.y);
			context.stroke();
		}

		ProfileLeave();
	}
}

function DrawActiveToolTip()
{
	if(SubMenuActive == -1)
	{
		if(ToolTipImmediate)
		{
			DrawToolTip(ToolTipImmediate, CanvasDetailedView, MouseX, MouseY);
			ToolTipImmediate = null;
		}
		else if(ToolTipCallback)
		{
			var Strings = ToolTipCallback(CanvasDetailedView, MouseX, MouseY);
			if(Strings)
			{
				DrawToolTip(Strings, CanvasDetailedView, MouseX, MouseY);
			}
		}
	}
	ToolTipCallback = null;
}
let PendingDraw = 0;

function Draw()
{
	PendingDraw = 0;
	ProfileEnter("Total");

	if(Settings.ViewActive == VIEW_CSV || (WSConnected && WS && WS.readyState == 1))
	{
		DrawViews();
		DrawMessage();
		DrawMenu();
	}
	else
	{
		var context = CanvasDetailedView.getContext('2d');
		context.clearRect(0, 0, nWidth, nHeight);
		DrawMessage();
	}

	DrawPlotf(CanvasDetailedView);
	DrawActiveToolTip();


	ProfileLeave();
	ProfileModeDraw(CanvasDetailedView);
	ProfileModeClear();


	PlotfClear();

	MouseReleased = false;
}
function RequestDraw()
{
	if(!PendingDraw)
	{
		PendingDraw = 1;
		requestAnimationFrame(Draw);
	}
}

function MeasureWidth(str)
{
	var context = CanvasDetailedView.getContext('2d');
	return context.measureText(str).width;
}

function AllocClearedArray(Size)
{
	var A = new Array(Size);
	for(var i = 0; i < Size; ++i)
	{
		A[i] = 0;
	}
	return A;
}
function PushIntoArray(A, v)
{
	A.shift();
	A.push(v);
}


function MouseDragPan()
{
	return MouseDragButton == 1 || MouseDragKeyShift;
}
function MouseDragSelectRange()
{
	return MouseDragState == MouseDragMove && (MouseDragButton == 3 || (MouseDragKeyShift&&MouseDragKeyCtrl));
}

function MouseHandleDrag()
{
	if(MouseDragTarget == CanvasDetailedView)
	{
		if(SubMenuActive == -1)
		{
			if(MouseDragSelectRange() && SubMenuActive == -1)
			{
				var xStart = MouseDragXStart;
				var xEnd = MouseDragX;
				if(xStart > xEnd)
				{
					var Temp = xStart;
					xStart = xEnd;
					xEnd = Temp;
				}
				if(xEnd - xStart > 1)
				{
					MouseDragActiveXStart = xStart;
					MouseDragActiveXEnd = xEnd;
				}
			}
			else if(MouseDragPan())
			{
				var X = MouseDragX - MouseDragXLast;
				var Y = MouseDragY - MouseDragYLast;
				if(X && MouseDragActiveXStart < MouseDragActiveXEnd)
				{
					MouseDragActiveXStart += X;
					MouseDragActiveXEnd += X;
				}
			}
			else if(MouseDragKeyCtrl)
			{
				if(MouseDragY != MouseDragYLast)
				{
					ZoomGraph(MouseDragY - MouseDragYLast);
				}
			}
			if(Settings.ViewActive == VIEW_BAR)
			{
				if(MouseDragKeyShift || MouseDragButton == 1)
				{
					var X = MouseDragX - MouseDragXLast;
					var Y = MouseDragY - MouseDragYLast;
					nOffsetBarsY -= Y;
					nOffsetBarsX -= X;
					if(nOffsetBarsY < 0)
					{
						nOffsetBarsY = 0;
					}
					if(nOffsetBarsX < 0)
					{
						nOffsetBarsX = 0;
					}
				}
			}
			if(Settings.ViewActive == VIEW_COUNTERS)
			{
				if(MouseDragKeyShift || MouseDragButton == 1)
				{
					var Y = MouseDragY - MouseDragYLast;
					nOffsetCountersY -= Y;
					if(nOffsetCountersY < 0)
					{
						nOffsetCountersY = 0;
					}
				}
			}
		}
		else if(SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuFunctions)
		{
			if(MouseDragKeyShift || MouseDragButton == 1)
			{
				var Y = MouseDragY - MouseDragYLast;
				if(SubMenuActive == SubMenuTimers)
				{
					nOffsetMenuTimers -= Y;
					if(nOffsetMenuTimers < 0)
					{
						nOffsetMenuTimers = 0;
					}
				}
				else if(SubMenuActive == SubMenuFunctions)
				{
					nOffsetMenuFunctions -= Y;
					if(nOffsetMenuFunctions < 0)
					{
						nOffsetMenuFunctions = 0;
					}
				}
				else
				{
					nOffsetMenuGroup -= Y;
					if(nOffsetMenuGroup < 0)
					{
						nOffsetMenuGroup = 0;
					}
				}
			}
		}
	}
	MouseDragXLast = MouseDragX;
	MouseDragYLast = MouseDragY;
}
function MouseHandleDragEnd()
{
	if(MouseDragTarget == CanvasDetailedView)
	{

	}
}

function MouseHandleDragClick()
{
	if(SubMenuActive == -1)
	{
		if(nHoverCounter != -1)
		{
			if(TimerArray[nHoverCounter].firstchild != -1)
			{
				TimerArray[nHoverCounter].closed = !TimerArray[nHoverCounter].closed;
			}
			else
			{
				TimerArray[nHoverCounter].Expanded = !TimerArray[nHoverCounter].Expanded;
			}
			Draw(1);
		}
	}
	if(MouseInCaptureButton)
	{
		TriggerCapture();
	}
}

function MapMouseButton(event)
{
	if(event.button == 1 || event.which == 1)
	{
		return 1;
	}
	else if(event.button == 3 || event.which == 3)
	{
		return 3;
	}
	else
	{
		return 0;
	}
}

function MouseDragReset()
{
	MouseDragState = MouseDragOff;
	MouseDragTarget = 0;
	MouseDragKeyShift = 0;
	MouseDragKeyCtrl = 0;
	MouseDragButton = 0;
}
function MouseDragKeyUp()
{
	if((MouseDragKeyShift && !KeyShiftDown) || (MouseDragKeyCtrl && !KeyCtrlDown))
	{
		MouseHandleDragEnd();
		MouseDragReset();
	}
}
function MouseDrag(Source, Event)
{
	if(Source == MouseDragOff || (MouseDragTarget && MouseDragTarget != Event.target))
	{
		MouseDragReset();
		return;
	}

	var LocalRect = Event.target.getBoundingClientRect();
	MouseDragX = Event.clientX - LocalRect.left;
	MouseDragY = Event.clientY - LocalRect.top;
	if(MouseDragState == MouseDragMove)
	{
		var dx = Math.abs(MouseDragX - MouseDragXStart);
		var dy = Math.abs(MouseDragY - MouseDragYStart);
		if((Source == MouseDragUp && MapMouseButton(Event) == MouseDragButton) ||
			(MouseDragKeyCtrl && !KeyCtrlDown) ||
			(MouseDragKeyShift && !KeyShiftDown))
		{
			MouseHandleDragEnd();
			MouseDragReset();
			return;
		}
		else
		{
			MouseHandleDrag();
		}
	}
	else if(MouseDragState == MouseDragOff)
	{
		if(Source == MouseDragDown || KeyShiftDown || KeyCtrlDown)
		{
			MouseDragTarget = Event.target;
			MouseDragButton = MapMouseButton(Event);
			MouseDragState = MouseDragDown;
			MouseDragXStart = MouseDragX;
			MouseDragYStart = MouseDragY;
			MouseDragKeyCtrl = 0;
			MouseDragKeyShift = 0;

			if(KeyShiftDown || KeyCtrlDown)
			{
				MouseDragKeyShift = KeyShiftDown;
				MouseDragKeyCtrl = KeyCtrlDown;
				MouseDragState = MouseDragMove;
			}
		}
	}
	else if(MouseDragState == MouseDragDown)
	{
		if(Source == MouseDragUp)
		{
			MouseHandleDragClick();
			MouseDragReset();
		}
		else if(Source == MouseDragMove)
		{
			var dx = Math.abs(MouseDragX - MouseDragXStart);
			var dy = Math.abs(MouseDragY - MouseDragYStart);
			if(dx+dy>1)
			{
				MouseDragState = MouseDragMove;
			}
		}
	}
	MouseDragXLast = MouseDragX;
	MouseDragYLast = MouseDragY;
}


function MouseMove(evt)
{
    evt.preventDefault();
	var rect = evt.target.getBoundingClientRect();
	var x = evt.clientX - rect.left;
	var y = evt.clientY - rect.top;
	MouseX = x;
	MouseY = y;
	MouseMoveTime = new Date();
    MouseDrag(MouseDragMove, evt);
    RequestDraw();
}


function MouseSortClick()
{
	if(SubMenuActive == -1)
	{
		if(SortColumnMouseOverNext)
		{
			if(SortColumnMouseOverNext == Settings.SortColumnName)
			{
				Settings.SortColumnOrderFlip =  1 - Settings.SortColumnOrderFlip;
			}
			else
			{
				Settings.SortColumnOrderFlip = 0;
			}

			Settings.SortColumnName = SortColumnMouseOverNext;
			SortColumnMouseOverNext = null;
		}
	}
}


function MouseButton(bPressed, evt)
{
    evt.preventDefault();
	MouseReleased = !bPressed;
	MouseDrag(bPressed ? MouseDragDown : MouseDragUp, evt);
	if(!bPressed)
		MouseSortClick();
    RequestDraw();
}

function MouseOut(evt)
{
	MouseDrag(MouseDragOff, evt);
	KeyCtrlDown = 0;
	KeyShiftDown = 0;
	// MouseDragButton = 0;
	// nHoverToken = -1;
	// RangeCpu = RangeInit();
}

function ZoomGraph(nZoom)
{
	gGraphCSVInvalid = 1;
	let fOldRange = gRange;
	let nModDown = 0;
	if(nZoom>0)
	{
		gRange *= Math.pow(nModDown ? 1.40 : 1.03, nZoom);
	}
	else
	{
		let fNewDetailedRange = gRange / Math.pow((nModDown ? 1.40 : 1.03), -nZoom);
		if(fNewDetailedRange < 0.0001) //100ns
			fNewDetailedRange = 0.0001;
		gRange = fNewDetailedRange;
	}

	let fDiff = fOldRange - gRange;
	let fMousePrc = MouseX / nWidth;
	if(fMousePrc < 0)
	{
		fMousePrc = 0;
	}
	gOffset += fDiff * fMousePrc;
	if(gRange > 1)
	{
		gRange = 1;
	}
	gOffset = Math.max(0, gOffset);
	if(gOffset + gRange > 1)
	{
		gOffset = 1 - gRange;
	}
	console.log("OFF ", gOffset, " Range", gRange);
}

function MouseWheel(e)
{
    var e = window.event || e;
    let delta = (e.wheelDelta || e.detail * (-120));
	ZoomGraph((-4 * delta / 120.0) | 0);
	RequestDraw();
}

function KeyUp(evt)
{
	var k = evt.keyCode;
	var InputActive = SubMenuActive == SubMenuTimers || SubMenuActive == SubMenuGroup || SubMenuActive == SubMenuFunctions || SubMenuActive == SubMenuPatched || SubMenuActive == SubMenuModules;
	if(k == 72)
	{
		KeyHDown = 0;
		UpdateShowHelp();
	}



	if(!InputActive)
	{
		if(k == 220)
		{
			ProfileMode = !ProfileMode;
		}
		if(k == 32)
		{
			CSVActiveSet = (CSVActiveSet + 1) % (CSVNumSets+1);
			gGraphCSVInvalid = 1;
		}
	}
	if(k >= 49 && k < 49 + MAX_GRAPHS)
	{
		NumGraphs = (k-49) + 1;
		gGraphCSVInvalid = 1;
	}
	if(k == 27)
	{
		if(FilterInput.value.trim() != "")
		{
			FilterInput.value = "";
		}
		else
		{
			EnableMenu(-1);
		}

		MouseDragActiveXStart = MouseDragActiveXEnd = -1;
		Settings.SortColumnName = "";
		ShowHelp(0);
	}

	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 0;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 16)
	{
		KeyShiftDown = 0;
		MouseDragKeyUp();
	}
	RequestDraw();
}

function KeyDown(evt)
{
	// console.log("keydow ", k);
	if(evt.keyCode == 72)
	{
		KeyHDown = 1;
		UpdateShowHelp();
	}
	if(evt.keyCode == 17)
	{
		KeyCtrlDown = 1;
		MouseDragKeyUp();
	}
	if(evt.keyCode == 16)
	{
		KeyShiftDown = 1;
		MouseDragKeyUp();
	}
}


function SetupEvents()
{
	var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"; //FF doesn't recognize mousewheel as of
	CanvasDetailedView.addEventListener('mousemove', MouseMove, false);
	CanvasDetailedView.addEventListener('mousedown', function(evt) { MouseButton(true, evt); });
	CanvasDetailedView.addEventListener('mouseup', function(evt) { MouseButton(false, evt); } );
	CanvasDetailedView.addEventListener('mouseout', MouseOut);
	CanvasDetailedView.addEventListener("contextmenu", function (e) { e.preventDefault(); }, false);
	CanvasDetailedView.addEventListener(mousewheelevt, MouseWheel, false);
	window.addEventListener('keydown', KeyDown);
	window.addEventListener('keyup', KeyUp);
	window.addEventListener('resize', ResizeCanvas, false);
}

function DrawToolTip(StringArray, Canvas, x, y)
{
	if(!ShowMenu())
	{
		return;
	}
	let colors;
	let a = StringArray;
	if(StringArray.c)
	{
		a = StringArray.a;
		colors = StringArray.c;
	}
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(a.length);
	var nMaxWidth = 0;
	var nHeight = 0;
	for(var i = 0; i < a.length; i += 2)
	{
		var nWidth0 = context.measureText(a[i]).width;
		var nWidth1 = context.measureText(a[i+1]).width;
		var nSum = nWidth0 + nWidth1;
		WidthArray[i] = nWidth0;
		WidthArray[i+1] = nWidth1;
		if(nSum > nMaxWidth)
		{
			nMaxWidth = nSum;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	//bounds check.
	x = Math.max(0, x - 10 - nMaxWidth);
	var CanvasRect = Canvas.getBoundingClientRect();
	if(y + nHeight > CanvasRect.height)
	{
		y = CanvasRect.height - nHeight;
		x += 20;
	}
	if(x + nMaxWidth > CanvasRect.width)
	{
		x = CanvasRect.width - nMaxWidth;
	}

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	context.fillStyle = 'white';
	for(i = 0; i < a.length; i += 2)
	{
		if(colors)
			context.fillStyle = colors[i];
		context.fillText(a[i], XPos, YPos);
		if(colors)
			context.fillStyle = colors[i+1];
		context.fillText(a[i+1], XPosRight - WidthArray[i+1], YPos);
		YPos += BoxHeight;
	}
	context.fillStyle = 'white';
}

function DrawPlotf(Canvas)
{
	return;
	var context = Canvas.getContext('2d');
	context.font = Font;
	var WidthArray = Array(PlotfArray.length);
	var nMaxWidth = 0;
	var nHeight = 0;

	context.font = Font;
	for(i = 0; i < PlotfArray.length; i++)
	{
		var nWidth = context.measureText(PlotfArray[i]).width;
		WidthArray[i] = nWidth;
		if(nWidth > nMaxWidth)
		{
			nMaxWidth = nWidth;
		}
		nHeight += BoxHeight;
	}
	nMaxWidth += 15;
	var x = 0;
	var y = 0;

	context.fillStyle = 'black';
	context.fillRect(x-1, y, nMaxWidth+2, nHeight);
	context.fillStyle = 'white';

	var XPos = x;
	var XPosRight = x + nMaxWidth;
	var YPos = y + BoxHeight-2;
	for(i = 0; i < PlotfArray.length; i++)
	{
		context.fillText(PlotfArray[i], XPos, YPos);
		YPos += BoxHeight;
	}
}


function ShiftRight10(v)
{
	if(v > 1024)
	{
		return v / 1024.0;
	}
	else
	{
		return v >> 10;
	}
}

function FormatCounter(Format, Counter)
{
	if(!Counter)
	{
		return '0';
	}
	var Negative = 0;
	if(Counter < 0)
	{
		Counter = -Counter;
		Negative = 1;
		if(Counter < 0) // handle INT_MIN
		{
			Counter = -(Counter+1);
			if(Counter < 0)
			{
				return '?';
			}
		}
	}
	var str = Negative ? '-' :'' ;
	if(Format == FormatCounterDefault)
	{
		var Seperate = 0;
		var result = '';
		while (Counter)
		{
			if (Seperate)
			{
				result += '.';
			}
			Seperate = 1;
			for (var i = 0; Counter && i < 3; ++i)
			{
				var Digit = Math.floor(Counter % 10);
				Counter = Math.floor(Counter / 10);
				result += '' + Digit;
			}
		}

		for(var i = 0; i < result.length; ++i)
		{
			str += result[result.length-1-i];
		}
		return str;
	}
	else if(Format == FormatCounterBytes)
	{
		var Shift = 0;
		var Divisor = 1;
		var CountShifted = ShiftRight10(Counter);
		while(CountShifted)
		{
			Divisor <<= 10;
			CountShifted = ShiftRight10(CountShifted);
			Shift++;
		}
		if(Shift)
		{
			return str + (Counter / Divisor).toFixed(2) + '' + FormatCounterBytesExt[Shift];
		}
		else
		{
			return str + Counter.toFixed(2) + '' + FormatCounterBytesExt[0];
		}
	}
	return '?';
}


function ShowHelp(Show, Toggle)
{
	var HelpWindow = document.getElementById('helpwindow');
	if(Toggle)
	{
		if(HelpWindow.style['display'] == 'block')
		{
			HelpWindow.style['display'] = 'none';
		}
		else
		{
			HelpWindow.style['display'] = 'block';
		}
	}
	else
	{
		if(Show)
		{
			HelpWindow.style['display'] = 'block';
		}
		else
		{
			HelpWindow.style['display'] = 'none';
		}
	}
}

function ParseUrl()
{
	var path = window.location.pathname;
	var idx = path.indexOf('/');
	if(idx < 0)
		return;
	var StrCommand = path.substring(idx+1);
	idx = StrCommand.indexOf('/');
	if(idx < 0)
		return;
	var StrSettings = StrCommand.substring(idx+1);
	PresetToLoad = StrSettings;
	PresetToLoadRO = StrCommand[0] == 'b';
}


function GetCookie()
{
	var result = document.cookie.match(/fisk=([^;]+)/);
	if(result && result.length > 0)
	{
		var Obj = JSON.parse(result[1]);
		if(!Obj.offline)
		{
			var C = {};
			C.offline = Obj;
			Obj = C;
		}
		return Obj;
	}
	else
	{
		return {offline:{},live:{}};
	}
}

function ReadCookie()
{
	var C = GetCookie().live;
	for(var i in C)
	{
		Cookie[i] = C[i];
	}
}
function WriteCookie()
{
	var C = GetCookie();
	C.live = {};
	for(var i in Cookie)
	{
		C.live[i] = Cookie[i];
	}

	var date = new Date();
	date.setFullYear(2099);
	var cookie = 'fisk=' + JSON.stringify(C) + ';expires=' + date;
	document.cookie = cookie;
}

// Shared graph code begin
let GRAPH_DRAW_FILLED = 1;
let GRAPH_DRAW_LINES = 2;
let GRAPH_DRAW_SECTION = 3;

function CreateGraph2Data(Samples, Name, Color, Mode, Samples2)
{
	let gd = {};
	let min = 1e38;
	let max = 0;
	gd.Samples = Samples;
	gd.Samples2 = Samples2;
	for(let i = 0; i < Samples.length; ++i)
	{
		min = Math.min(min, Samples[i]);
		max = Math.max(max, Samples[i]);
	}
	if(Samples2)
	{
		for(let i = 0; i < Samples2.length; ++i)
		{
			min = Math.min(min, Samples2[i]);
			max = Math.max(max, Samples2[i]);
		}
	}
	gd.Min = min;
	gd.Max = max;
	gd.Name = Name;
	gd.Color = Color;
	gd.Mode = Mode;
	return gd;
}


function CreateDrawGraph2Parameters()
{
	let P = {};
	P.Rect = WindowRect(0, 0, 1, 1);
	P.RangeMin = 0.0;
	P.RangeMax = 0.0;
	P.Mark = [16.66, 33.33];
	P.Ext = "ms";
	P.Border = 2;
	P.Frame = 1;
	P.Digits = -1;
	P.DrawMode = GRAPH_DRAW_FILLED;
	P.xRange = 1;
	P.xOffset = 0;
	P.FullDraw = 1;
	return P;
}



function DrawGraph2(context, Parameters, data, Mouse)
{
	ProfileEnter("DrawGraph2");
	let Rect = Parameters.Rect;
	let RangeMin = Parameters.RangeMin;
	let RangeMax = Parameters.RangeMax;
	let xRangeFloat = Parameters.xRange;
	let xOffsetFloat = Parameters.xOffset;
	let FullDraw = Parameters.FullDraw;
	let MaxLen = 0;
	let MaxSample = 0;
	let MinSample = 1e25;
	let xOffset = 0;
	let xRange = 0;


	for(let i in data)
	{
		let d = data[i];
		if(MaxLen == 0)
		{
			MaxLen = d.Samples.length;
			if(xRangeFloat >= 1.0)
			{
				xOffset = 0;
				xRange = MaxLen;
			}
			else
			{
				xOffset = Math.floor(xOffsetFloat * MaxLen);
				xRange = Math.floor(xRangeFloat * MaxLen);
			}

		}
		if(!d.Samples.length == MaxLen)
			debugger;
		MaxLen = Math.max(MaxLen, d.Samples.length);
		if(d.Samples2)
		{
			if(!d.Samples2.length == MaxLen)
				debugger;
		}

		//calc rangemin/max only on change
 		if(xOffset != 0 || xRange != MaxLen)
 		{
			if(!d.RangeMinMax || d.RangeMinMax.Offset != xOffset || d.RangeMinMax.Range != xRange)
			{
				d.RangeMinMax = {};
				d.RangeMinMax.Offset = xOffset;
				d.RangeMinMax.Range = xRange;
				let LocalMax = 0;
				let LocalMin = 1e25;
				for(let i = 0; i < xRange; ++ i)
				{
					LocalMax = Math.max(LocalMax, d.Samples[i + xOffset]);
					LocalMin = Math.min(LocalMin, d.Samples[i + xOffset]);
					if(d.Samples2)
					{
						LocalMax = Math.max(LocalMax, d.Samples2[i + xOffset]);
						LocalMin = Math.min(LocalMin, d.Samples2[i + xOffset]);
					}
				}
				d.RangeMinMax.LocalMin = LocalMin;
				d.RangeMinMax.LocalMax = LocalMax;
			}
			MaxSample = Math.max(d.RangeMinMax.LocalMax, MaxSample);
			MinSample = Math.min(d.RangeMinMax.LocalMin, MinSample);
 		}
 		else
 		{
			MaxSample = Math.max(d.Max, MaxSample);
			MinSample = Math.min(d.Min, MinSample);
 		}
	}
	if(0 == MaxLen)
		return;

	if(RangeMax <= RangeMin)
	{
		RangeMin = MinSample;
		RangeMax = MaxSample;
	}
	RangeMin = 0;


	let Ext = Parameters.Ext;
	let Border = Parameters.Border;
	let Frame = Parameters.Frame;
	if(Frame)
		Border += 10;

	let wx = Rect.x;
	let wy = Rect.y;
	let wh = Rect.h;
	let ww = Rect.w;

	let x = Rect.x + Border;
	let y = Rect.y + Border;
	let h = Rect.h - 2*Border;
	let w = Rect.w - 2*Border;

	let MouseX = Mouse.X-x;
	let MouseY = Mouse.Y-y;
	let MouseInside = Mouse.X >= x && Mouse.Y >= y && Mouse.X < x + w && Mouse.Y < y + h;
	let MouseXPrc = (Mouse.X - x) / (w-1);
	if(FullDraw)
	{
		context.clearRect(wx, wy, ww, wh);
	}

	let SampleWidth = w / (xRange-1);
	let MouseIndex = Math.max(0, Math.min(MaxLen-1, xOffset + Math.floor(MouseXPrc * xRange)));

	let HeightScale = h / (RangeMax-RangeMin);
	let Y = y + h;
	let YStart = Y;
	let GRAPH_ALPHA = 0.2;
	let SECTION_ALPHA = 0.3;
	let MouseDrawX;
	for(let dataindex in data)
	{
		let LocalElement = data[dataindex];
		let Samples = LocalElement.Samples;
		let Samples2 = LocalElement.Samples2;
		let Mode = LocalElement.Mode;
		let X = x + w - (xRange-1)*SampleWidth;
		Y = y + h;

		context.globalAlpha = 1;
		context.strokeStyle = LocalElement.Color;
		context.fillStyle = LocalElement.Color;
		if(FullDraw)
		{
			context.beginPath();
			for(let i = 0; i < xRange; ++i)
			{
				let idx = xOffset + i;
				Y = Math.max(YStart - Samples[idx] * HeightScale, y);
				if(i == 0)
					context.moveTo(X, Y);
				else
					context.lineTo(X, Y);
				X += SampleWidth;

			}

			if(Mode == GRAPH_DRAW_SECTION)
			{
				if(!Samples2)
					debugger;
				let len = Samples2.length;
				for(let i = 0; i < xRange; ++i)
				{
					X -= SampleWidth;
					let I = xOffset + xRange - i - 1;
					Y = Math.max(YStart - Samples2[I] * HeightScale, y);
					context.lineTo(X, Y);
				}
				context.globalAlpha = SECTION_ALPHA;
				context.fill();
			}
			else
			{
				context.stroke();
				context.lineTo(X-SampleWidth, YStart);
				context.lineTo(x, YStart);
				if(Mode == GRAPH_DRAW_FILLED)
				{
					context.globalAlpha = GRAPH_ALPHA;
					context.fill();
				}
			}
		}
		else
		{
			if(MouseInside && Mode != GRAPH_DRAW_SECTION)
			{
				let MouseSample = Samples[MouseIndex];
				let Y = Math.max(YStart - MouseSample * HeightScale, y);
				let X = x + w + (MouseIndex - (xOffset + xRange-1))*SampleWidth;
				MouseDrawX = X;

				context.globalAlpha = 0.8;
				context.beginPath();
				context.arc(X, Y, 2, 0, 2 * Math.PI);
				context.fill();

				context.globalAlpha = 1;

				context.beginPath();
				context.arc(X, Y, 3, 0, 2 * Math.PI);
				context.stroke();
			}
		}

	}
	context.globalAlpha = 1;
	context.fillStyle = 'wheat';
	context.strokeStyle = 'wheat';
	context.textAlign='right';

	if(FullDraw)
	{
		context.fillText(FormatNumber(RangeMax, Parameters.Digits) + Ext, x+w, y + FontHeight);
		for(let m in Parameters.Mark)
		{
			let Sample = Parameters.Mark[m];
			if(Sample < MaxSample)
			{
				let Y = YStart - Sample * HeightScale;
				context.fillText(Sample + Ext, x+w, Y + FontHeight);
			}
		}


		context.globalAlpha = 0.4;
		for(let m in Parameters.Mark)
		{
			let Sample = Parameters.Mark[m];
			let Y = YStart - Sample * HeightScale;
			if(Sample < MaxSample);
			{
				context.beginPath();
				context.moveTo(x-(Frame?5:0), Y);
				context.lineTo(x+w, Y);
				context.stroke();
			}
		}
		context.globalAlpha = 1;
		if(Frame)
		{
			context.beginPath();
			context.moveTo(x-5, YStart);
			context.lineTo(x+w+5, YStart);
			context.stroke();



			context.beginPath();
			context.moveTo(x, YStart+5);
			context.lineTo(x, YStart-h-5);
			context.stroke();

			context.beginPath();
			context.moveTo(x, YStart-h);
			context.lineTo(x-5, YStart-h);
			context.stroke();


			context.textAlign= "right";
			context.fillText((xRange+xOffset) + '', x+w, YStart+FontHeight);
			if(MouseDrawX)
			{
				context.textAlign= "right";
				context.fillText((MouseIndex) + '', MouseDrawX, YStart+FontHeight);
			}

			context.textAlign= "left";
			context.fillText(xOffset + '', x+2, YStart+FontHeight);
		}


		let localindex = 0;
		for(let dataindex = 0; dataindex < data.length; ++dataindex)
		{
			let LocalElement = data[dataindex];
			if(LocalElement.Mode != GRAPH_DRAW_SECTION)
			{
				context.textAlign='left';
				context.strokeStyle = LocalElement.Color;
				context.fillStyle = LocalElement.Color;
				context.fillText(LocalElement.Name, x+2, y + FontHeight * (localindex+1));
				localindex++;
			}
		}

	}
	else
	{
		if(Frame)
		{
			if(MouseDrawX)
			{
				context.textAlign= "right";
				context.fillText((MouseIndex) + '', MouseDrawX, YStart+FontHeight);
			}
		}

		if(MouseInside)
		{
			ToolTipImmediate = new Array();
			for(let dataindex in data)
			{
				let LocalElement = data[dataindex];
				if(LocalElement.Mode != GRAPH_DRAW_SECTION)
				{
					/// MAKE TOOLTIPS SHOW: MIN, MAX, AVG, Percentile, variance.
					let Samples = LocalElement.Samples;
					ToolTipImmediate.push(LocalElement.Name);
					ToolTipImmediate.push("            " + Samples[MouseIndex].toFixed(4).slice(-12));
				}

			}
		}

	}

	ProfileLeave();
}
// Shared graph code end


function CreateCSVSetFile(Set, Filename)
{
	let File = {};
	File.Name = Filename;
	File.DataSorted = [];
	File.Data = [];
	File.ColumnToIndex = {};
	File.ColumnsSorted = {};
	File.Columns = {};
	return File;

}
function CreateCSVSet()
{
	let Index = ++CSVIndex;
	let Name = "Set_" + Index;
	let Set = {};
	Set.Name = Name;
	Set.Files = {};
	Set.Columns = {};
	Set.ColumnNames = {};
	Set.GraphDataMin = {};
	Set.GraphDataMax = {};
	Set.GraphDataAvg = {};
	Set.GraphDataSect = {};
	Set.GraphDataPercentileAvg = {};
	Set.GraphDataPercentileMin = {};
	Set.GraphDataPercentileMax = {};
	Set.GraphDataPercentileSect = {};
	Set.ColumnIndex = 0;
	Set.PendingCount = 0;
	Set.FinishedCount = 0;
	Set.Ready = false;
	return Set;
}
function EnlargeArray(a, size)
{
	let count = size - a.length;
	if(count < 0)
		debugger;
	let A = new Array();
	for(let i = 0; i < count; ++i)
		A.push(0);
	for(let i = 0; i < a.length; ++i)
	{
		A.push(a[i]);
	}
	return A;
}

function EnlargeAllArrays(set)
{
	for(let name in set)
	{
		let data = set[name];
		data.Samples = EnlargeArray(data.Samples, CSVMaxLength);
		if(data.Samples2)
			data.Samples2 = EnlargeArray(data.Samples2, CSVMaxLength);

	}
}

function ParseCSVCheckFinished(Name)
{
	let Set = CSVSets[Name];

	console.log("Finished parsing ", Set.FinishedCount, ":", Set.PendingCount);
	if(Set.FinishedCount == Set.PendingCount)
	{
		if(Set.FinishedCount == 0)
		{
			console.error("No CSV files were parsable");
			CSVSets[Name] = null;
		}
		else
		{
			console.log("Done parsing csv files");
			let MaxCount = CSVMaxLength;
			//find the max column length
			for(let F in Set.Files)
			{
				let File = Set.Files[F];
				for(let CName in File.Columns)
					if(File.Columns[CName])
						MaxCount = Math.max(MaxCount, File.Columns[CName].length);
			}
			CSVMaxLength = MaxCount;
			for(let F in Set.Files)
			{
				let File = Set.Files[F];
				for(let CName in File.Columns)
					if(File.Columns[CName])
						if(File.Columns[CName].length < MaxCount)
						{
							File.Columns[CName] = EnlargeArray(File.Columns[CName], MaxCount);
						}
			}


			for(let CName in Set.ColumnNames)
			{
				CSVAllColumns[CName] = 1;
				let aggr = {};
				console.log("aggr for ", CName);



				let count = new Array(MaxCount);
				let sum = new Array(MaxCount);
				let min = new Array(MaxCount);
				let max = new Array(MaxCount);
				let avg = new Array(MaxCount);
				let min_perc = new Array(MaxCount);
				let max_perc = new Array(MaxCount);
				let avg_perc = new Array(MaxCount);
				for(let i = 0; i < MaxCount; ++i)
				{
					count[i] = 0;
					sum[i] = 0;
					min[i] = 1e28;
					max[i] = -1e28;
				}
				for(let F in Set.Files)
				{
					let File = Set.Files[F];
					if(File.Columns[CName])
					{
						let c = File.Columns[CName];
						for(let i = 0; i < c.length; ++i)
						{
							count[i]++;
							sum[i] += c[i];
							min[i] = Math.min(c[i], min[i]);
							max[i] = Math.max(c[i], max[i]);

						}
					}
				}
				for(let i = 0; i < MaxCount; ++i)
				{
					if(count[i])
					{
						avg[i] = sum[i] / count[i];
					}
					else
					{
						min[i] = 0;
						max[i] = 0;
					}
				}
				for(let i = 0;i < MaxCount; ++i)
				{
					min_perc[i] = min[i];
					max_perc[i] = max[i];
					avg_perc[i] = avg[i];
				}
				let comp = function(l, r){ return l-r;};

				min_perc.sort(comp);
				max_perc.sort(comp);
				avg_perc.sort(comp);

				let name = CName;
				let FullName = Name + "/"+ CName;
				let color0 = ColorFromString(FullName, 70,  60);
				let color1 = ColorFromString(FullName, 80,  60);
				let color2 = ColorFromString(FullName, 80,  30);
				Set.GraphDataMin[CName] = CreateGraph2Data(min, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataMax[CName] = CreateGraph2Data(max, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataAvg[CName] = CreateGraph2Data(avg, FullName, color1, GRAPH_DRAW_LINES);
				Set.GraphDataSect[CName] = CreateGraph2Data(max, FullName, color0, GRAPH_DRAW_SECTION, min);
				Set.GraphDataPercentileAvg[CName] = CreateGraph2Data(avg_perc, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataPercentileMin[CName] = CreateGraph2Data(min_perc, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataPercentileMax[CName] = CreateGraph2Data(max_perc, FullName, color0, GRAPH_DRAW_LINES);
				Set.GraphDataPercentileSect[CName] = CreateGraph2Data(max_perc, FullName, color0, GRAPH_DRAW_SECTION, min_perc);

			}

			for(let SetName in CSVSets)
			{
				let Set = CSVSets[SetName];
				EnlargeAllArrays(Set.GraphDataMin);
				EnlargeAllArrays(Set.GraphDataMax);
				EnlargeAllArrays(Set.GraphDataAvg);
				EnlargeAllArrays(Set.GraphDataSect);
				EnlargeAllArrays(Set.GraphDataPercentileAvg);
				EnlargeAllArrays(Set.GraphDataPercentileMin);
				EnlargeAllArrays(Set.GraphDataPercentileMax);
				EnlargeAllArrays(Set.GraphDataPercentileSect);
			}


			//enable some default graphs
			let GraphIndex = 0;
			let first = 1;
			for(let Column in CSVAllColumns)
			{
				if(first)
				{
					first = 0;
					continue;
				}
				let gs = Graphs[GraphIndex++];
				if(Object.keys(gs).length == 0)
				{
					gs[Column] = 1;
				}
				if(GraphIndex >= MAX_GRAPHS)
					break;
			}
			Set.Ready = true;
			gGraphCSVInvalid = 1;
			ActivateView(VIEW_CSV);
			RequestDraw();
		}
	}
}
function ParseCSVLine(Line)
{
	let Pos = 0;
	let Start = 0;
	let Len = Line.length;
	let InBrackets = 0;
	let Out = new Array();
	let BracketStart = -1;
	let BracketEnd = -1;
	let push = function()
	{
		if(BracketStart >= 0)
		{
			console.assert(BracketEnd >= 0);
			Out.push(Line.slice(BracketStart+1, BracketEnd));
		}
		else
		{
			Out.push(Line.slice(Start, Pos).trim());

		}
		Start = Pos+1;
		InBrackets = 0;
		BracketStart = -1;
		BracketEnd = -1;
	};
	while(Pos != Len)
	{
		let Char = Line[Pos];
		if(InBrackets)
		{
			if(Char == "\"")
			{
				BracketEnd = Pos;
				InBrackets = 0;
			}
		}
		else
		{
			if(Char == "\"")
			{
				BracketStart = Pos;
				InBrackets = 1;
			}
			else if(Char == ",")
			{
				push();
			}
		}
		Pos++;
	}
	push();
	return Out;

}

function ParseCSVFile(Set, Result, Name)
{
	let File = CreateCSVSetFile(Set, Name);
	let Lines = Result.split(/\r?\n/);
	let Headers, Data, DataSorted;
	let Columns = 0;
	for(let i = 0; i < Lines.length; ++i)
	{
		let LineData = ParseCSVLine(Lines[i]);
		if(i == 0)
		{
			Headers = LineData;
			Columns = Headers.length;

			Data = new Array(Columns);
			DataSorted = new Array(Columns);
			File.Data = Data;
			File.DataSorted = DataSorted;
			for(let j = 0; j < Columns; ++j)
			{
				Data[j] = new Array();
				DataSorted[j] = new Array();

				let ColumnName = Headers[j];
				File.ColumnToIndex[Headers[j]] = j;
				File.Columns[ColumnName] = Data[j];
				File.ColumnsSorted[ColumnName] = DataSorted[j];
				Set.ColumnNames[ColumnName] = 1;
			}
		}
		else
		{
			if(LineData.length != Columns)
			{
				console.log("Skipping line '" + Lines[i] + "'");
				continue;
			}
			for(let j = 0; j < Columns; ++j)
			{
				Data[j].push(parseFloat(LineData[j]));
				DataSorted[j].push(parseFloat(LineData[j]));
			}
		}
	}
	for(let j = 0; j < Columns; ++j)
	{
		DataSorted[j].sort();

	}
	Set.Files[Name] = File;
	Set.FinishedCount++;
	ParseCSVCheckFinished(Set.Name);

}

function ReadCSVFile(Set, File)
{
	if(!File)
		return;
	let Reader = new FileReader();
	Reader.onload = function(e) {
		let t0 = new Date();
		ParseCSVFile(Set, e.target.result, File.name);
		let t1 = new Date();
		console.log("Parsing took ", (t1-t0).toFixed(2));
	};
	Reader.onprogress = function(e)
	{
		var m = e.loaded + ":" + e.total + " :: " + e.lengthComputable;
		console.log(m);
	};
	Set.PendingCount++;
	Reader.readAsText(File);

}

function UpdateShowHelp(ForceShow)
{
	if(ForceShow || KeyHDown)
	{
	    document.querySelector(".dropzone").style.visibility = "";
	    document.querySelector(".dropzone").style.opacity = 1;
	}
	else
	{
        document.querySelector(".dropzone").style.visibility = "hidden";
        document.querySelector(".dropzone").style.opacity = 0;
	}
}

// magic from stack-overflow somewhere..
function WindowDragEnter(e)
{
    LastDropTarget = e.target;
    UpdateShowHelp(1);
};

function WindowDragLeave(e)
{
    if(e.target === LastDropTarget || e.target === document)
    {
    	UpdateShowHelp(0);
    }
};
function DropHandler(ev)
{
	UpdateShowHelp(0);
	LastDropTarget = null;

	let Set = CreateCSVSet();
	Set.PendingCount++;
	CSVSets[Set.Name] = Set;
	CSVSetNames.push(Set.Name);
	CSVNumSets++;
	for(let i = 0; i < ev.dataTransfer.files.length; ++i)
	{
		let File = ev.dataTransfer.files[i];
		let Name = File.name;
		let ExtMatch = Name.match(/\.[0-9a-zA-Z]+$/);
		let Ext = ExtMatch ? ExtMatch[0] : "";
		if(Ext.toLowerCase() == ".csv")
		{
			ReadCSVFile(Set, File);
		}
		else
		{
			console.log("Not a .csv file!\n" + Name);
		}
	}
	if(0 == Set.PendingCount)
	{
		window.alert("No dropped CSV files. Please drop one or more csv files to use csv viewer");
	}
	Set.FinishedCount++;
	ParseCSVCheckFinished(Set.Name);
  	ev.preventDefault();
}

function DragOverHandler(ev)
{
  ev.preventDefault();
}


ReadCookie();
ParseUrl();
ResizeCanvas();
SetupEvents();
InitMenu();
window.addEventListener("dragenter", WindowDragEnter);
window.addEventListener("dragleave", WindowDragLeave);
UpdateShowHelp(1);
RequestDraw();

//
// tooltip
// range selection + info
//
</script>
</body>
</html>


